<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="Rotation" Id="{83b74736-0e2a-4820-b07c-7378d567dc02}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM Rotation
VAR
//Outputs: Power for Limit switches, Home Sensors, etc.
    //bPowerSwitchesAxis1 AT %Q*: BOOL:= TRUE;
    bFwdLimitPower AT %Q* : BOOL := TRUE;
    bBwdLimitPower AT %Q* : BOOL := TRUE;
    bEnable : BOOL := TRUE;
    
    OpState : E_RotationBrakeCheckerState := E_RotationBrakeCheckerState.init;
    OpSate_String : STRING;
    bBrakeTestInProgress : BOOL;
    fbBrakeControl : FB_CoEAX8000BrakeControl;
    
    fbReadDriveOpMode : MC_ReadDriveOperationMode;
    driveOpModeReadIn : E_DriveOperationMode;
    sErrorMessage : STRING;
    bInBrakeTestMode AT %I* : BOOL;
    
    Brake1Valid AT %I* : BOOL;
    Brake1State AT %I* : BOOL;
    Brake2Valid AT %I* : BOOL;
    Brake2State AT %I* : BOOL;
    
    TriggerBrake1Test : BOOL; //PLC test trigger
    TriggerBrake2Test : BOOL; //PLC test trigger
    
    RunBrake1Test AT %Q* : BOOL; // Test trigger to safety system
    RunBrake2Test AT %Q* : BOOL; // Test trigger to safety system
    TestingBrake1 : BOOL;
    TestingBrake2 : BOOL;
    FinishBrakeTesting AT %Q* : BOOL;
    ManualReleaseBrake1 AT %Q* : BOOL;
    ManualReleaseBrake2 AT %Q* : BOOL;
    RotationSTOState AT %I* : BOOL;
    Reinitialise : BOOL; //Bool to get out of error state
    
    Brake1TimeRemaining_RAW AT %I* : UDINT; //In seconds
    Brake2TimeRemaining_RAW AT %I* : UDINT; //In seconds
    Brake1TimeRemaining_Breakdown : UDINT;
    Brake2TimeRemaining_Breakdown : UDINT;
    
    Brake1TimeRemaining_Days : UDINT;
    Brake1TimeRemaining_Hours : UDINT;
    Brake1TimeRemaining_Minutes : UDINT;
    Brake1TimeRemaining_Seconds : UDINT;
    
    
    Brake2TimeRemaining_Days : UDINT;
    Brake2TimeRemaining_Hours : UDINT;
    Brake2TimeRemaining_Minutes : UDINT;
    Brake2TimeRemaining_Seconds : UDINT;
    
    iQ_Current AT %I* : REAL;
    SBC_FailsafeFault AT %I* : BOOL;
    BC1_Error AT %I* : BOOL;
    BC2_Error AT %I* : BOOL;
    BrakeReset AT %Q* : BOOL;
    
    
    stateTimout : TON;
    brakeDelay : TON;
    loadDelay : TON;
    timeToClearValid : TON;
    brakeResetTon : TON;
    
    fbAx8000BrakeTest : FB_CoEAX8000BrakeTest;
    fbReset : MC_Reset();
    
    TEST_TORQUE : LREAL := 2.1;//1.4142;
    ResetCounter : INT;
    ResetCounterLimit : INT := 5;
//Hardware interlocks
    //bInterlockFwdOK AT %I*: BOOL;
END_VAR
VAR CONSTANT
    DAY_SECONDS : UDINT := 86400;
    HOUR_SECONDS : UDINT := 3600;
    MINUTE_SECONDS : UDINT := 60;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[OpSate_String := TO_STRING(OpState);
brakeResetTon(IN:=BrakeReset, PT:=T#250MS);
IF brakeResetTon.Q THEN
    BrakeReset:= FALSE;
END_IF

//Time conversion logic
Brake1TimeRemaining_Days:= Brake1TimeRemaining_RAW/DAY_SECONDS;
Brake1TimeRemaining_Breakdown := Brake1TimeRemaining_RAW MOD DAY_SECONDS;
Brake1TimeRemaining_Hours:= Brake1TimeRemaining_Breakdown/HOUR_SECONDS;
Brake1TimeRemaining_Breakdown:= Brake1TimeRemaining_Breakdown MOD HOUR_SECONDS;
Brake1TimeRemaining_Minutes:= Brake1TimeRemaining_Breakdown/MINUTE_SECONDS;
Brake1TimeRemaining_Breakdown:= Brake1TimeRemaining_Breakdown MOD MINUTE_SECONDS;
Brake1TimeRemaining_Seconds:= Brake1TimeRemaining_Breakdown;

Brake2TimeRemaining_Days:= Brake2TimeRemaining_RAW/DAY_SECONDS;
Brake2TimeRemaining_Breakdown := Brake2TimeRemaining_RAW MOD DAY_SECONDS;
Brake2TimeRemaining_Hours:= Brake2TimeRemaining_Breakdown/HOUR_SECONDS;
Brake2TimeRemaining_Breakdown:= Brake2TimeRemaining_Breakdown MOD HOUR_SECONDS;
Brake2TimeRemaining_Minutes:= Brake2TimeRemaining_Breakdown/MINUTE_SECONDS;
Brake2TimeRemaining_Breakdown:= Brake2TimeRemaining_Breakdown MOD MINUTE_SECONDS;
Brake2TimeRemaining_Seconds:= Brake2TimeRemaining_Breakdown;

//Actual brake logic
GVL_INTER.BRAKE_TEST_PASSED:= Brake1Valid AND Brake2Valid; //Feedback from safety system as to if brake test is passed

astAxes[AXIS_ROTATION].stControl.bEnable := FALSE;  //Will be overridden by state machine
astAxes[AXIS_ROTATION].stDescription.sAxisName := 'ROTATION';


IF NOT GVL_INTER.BRAKE_TEST_PASSED AND NOT bBrakeTestInProgress THEN
    OpState:= E_RotationBrakeCheckerState.init;
END_IF

CASE OpState OF
    E_RotationBrakeCheckerState.init:
        //Ensure motor cannot be enabled
        bBrakeTestInProgress:=FALSE;
        FinishBrakeTesting:=FALSE;
        
        //Ensure no "active brake test signals"
        RunBrake1Test:= FALSE;
        RunBrake2Test:= FALSE;
        ManualReleaseBrake1:=FALSE;
        ManualReleaseBrake2:=FALSE;
        IF GVL_INTER.BRAKE_TEST_PASSED THEN
            OpState:= E_RotationBrakeCheckerState.Set_Brake_Mode_To_Op;
        END_IF
        IF bInBrakeTestMode THEN
            bBrakeTestInProgress:= TRUE;
            OpState:= E_RotationBrakeCheckerState.Start_Brake_Test;            
		END_IF
    
    E_RotationBrakeCheckerState.Set_Brake_Mode_To_Op:
        fbBrakeControl.Execute:= TRUE;
        fbBrakeControl.Mode:= E_AX8000BrakeMode.eAX8000BrakeMode_Automatic;
        fbBrakeControl(Axis:= astAxes[AXIS_ROTATION].Axis);
        OpState:= E_RotationBrakeCheckerState.Check_Brake_Mode_To_Op;
    
    E_RotationBrakeCheckerState.Check_Brake_Mode_To_Op:
        fbBrakeControl(Axis:= astAxes[AXIS_ROTATION].Axis); //Run function block to update statuses    
        IF NOT fbBrakeControl.Busy AND NOT fbBrakeControl.Error THEN
            fbBrakeControl.Execute:= FALSE;
            fbBrakeControl.Mode:= E_AX8000BrakeMode.eAX8000BrakeMode_Automatic;
            fbBrakeControl(Axis:= astAxes[AXIS_ROTATION].Axis);
            OpState:= E_RotationBrakeCheckerState.Check_Drive_Mode_To_Op;
        ELSIF NOT fbBrakeControl.Busy AND fbBrakeControl.Error THEN
            fbBrakeControl.Execute:= FALSE;
            fbBrakeControl.Mode:= E_AX8000BrakeMode.eAX8000BrakeMode_Automatic;
            fbBrakeControl(Axis:= astAxes[AXIS_ROTATION].Axis);
            OpState:= E_RotationBrakeCheckerState.Error;
            sErrorMessage:= 'Unable to set brake mode to automatic whilst moving to inop';
        END_IF
        
    E_RotationBrakeCheckerState.Check_Drive_Mode_To_Op:
        fbReadDriveOpMode(Axis:= astAxes[AXIS_ROTATION].Axis,Execute:= TRUE);
        
        IF NOT fbReadDriveOpMode.Busy AND NOT fbReadDriveOpMode.Error THEN
            driveOpModeReadIn := fbReadDriveOpMode.DriveOperationMode;
            fbReadDriveOpMode(Axis:= astAxes[AXIS_ROTATION].Axis,Execute:= FALSE);
            IF driveOpModeReadIn = E_DriveOperationMode.DriveOperationMode_Pos1 OR driveOpModeReadIn = E_DriveOperationMode.DriveOperationMode_Default THEN
                OpState:= E_RotationBrakeCheckerState.In_Operation;
            ELSE
                OpState:= E_RotationBrakeCheckerState.Error;
                sErrorMessage:= 'Incorrect drive op mode when moving to InOp';
			END_IF
		END_IF
        IF NOT fbReadDriveOpMode.Busy AND fbReadDriveOpMode.Error THEN
            fbReadDriveOpMode(Axis:= astAxes[AXIS_ROTATION].Axis,Execute:= FALSE);
            OpState:= E_RotationBrakeCheckerState.Error;
            sErrorMessage:= 'Error reading drive operation mode';
		END_IF
        
     E_RotationBrakeCheckerState.In_Operation:
        //DO NOTHING
        ManualReleaseBrake1:=TRUE;
        ManualReleaseBrake2:=TRUE;
        astAxes[AXIS_ROTATION].stControl.bEnable := bEnable;
        
        IF NOT GVL_INTER.BRAKE_TEST_PASSED OR bInBrakeTestMode THEN
            OpState:= E_RotationBrakeCheckerState.init;
		END_IF
        
     E_RotationBrakeCheckerState.Error:
        ManualReleaseBrake1:= FALSE;
        ManualReleaseBrake2:= FALSE;
        ResetCounter:= 0;
        IF Reinitialise THEN
            OpState:= E_RotationBrakeCheckerState.init;
		END_IF
        
    //////////BRAKE TESTING SEQUENCE ////////
    E_RotationBrakeCheckerState.Start_Brake_Test:
        astAxes[AXIS_ROTATION].stControl.bEnable := FALSE;
        //Confirm brakes are on and unlock AX motor brake
        //Remember, to test brake 1, you must release brake 2!!!
        ManualReleaseBrake1:= FALSE;
        ManualReleaseBrake2:= FALSE;
        
        //Brakes are not on (holding)
        IF NOT Brake1State AND NOT Brake2State THEN
            //Release ax motor brake
            fbBrakeControl.Execute:= TRUE;
            fbBrakeControl.Mode:= E_AX8000BrakeMode.eAX8000BrakeMode_Unlock;
            fbBrakeControl(Axis:= astAxes[AXIS_ROTATION].Axis);
            
            IF NOT fbBrakeControl.Busy AND NOT fbBrakeControl.Error THEN
                fbBrakeControl.Execute:= FALSE;
                fbBrakeControl.Mode:= E_AX8000BrakeMode.eAX8000BrakeMode_Unlock;
                fbBrakeControl(Axis:= astAxes[AXIS_ROTATION].Axis);
                OpState:= E_RotationBrakeCheckerState.Reset_Axis;
            ELSIF NOT fbBrakeControl.Busy AND fbBrakeControl.Error THEN
                fbBrakeControl.Execute:= FALSE;
                fbBrakeControl.Mode:= E_AX8000BrakeMode.eAX8000BrakeMode_Automatic;
                fbBrakeControl(Axis:= astAxes[AXIS_ROTATION].Axis);
                OpState:= E_RotationBrakeCheckerState.Error;
                sErrorMessage:= 'Unable to set brake mode to automatic whilst performing brake test';
            END_IF
            
		END_IF
        
        E_RotationBrakeCheckerState.Reset_Axis:
        //NEED TO DO MY OWN RESET LOGIC HERE - WAS IN ERROR STATE
            astAxes[AXIS_ROTATION].stControl.bEnable := FALSE;
            ManualReleaseBrake1:= FALSE;
            ManualReleaseBrake2:= FALSE;
            astAxes[AXIS_ROTATION].stControl.bReset:= TRUE;
            
            stateTimout(IN:= TRUE, PT:=T#2S);
            GVL_INTER.RESET_ALL:= TRUE;
            //If no error
            IF NOT astAxes[AXIS_ROTATION].Axis.Status.Error THEN
                stateTimout(IN:= FALSE);
                OpState:= E_RotationBrakeCheckerState.Confirm_STO_State;
			END_IF
            IF stateTimout.Q THEN
                stateTimout(IN:= FALSE);
                OpState:= E_RotationBrakeCheckerState.Error;
                sErrorMessage:= 'Unable to reset axis error';
			END_IF
            
        E_RotationBrakeCheckerState.Confirm_STO_State:
            astAxes[AXIS_ROTATION].stControl.bEnable := FALSE;
            ManualReleaseBrake1:= FALSE;
            ManualReleaseBrake2:= FALSE;
            stateTimout(IN:= TRUE, PT:=T#2S);
            IF NOT RotationSTOState THEN
                stateTimout(IN:= FALSE);
                OpState:= E_RotationBrakeCheckerState.Enable_Motor;
			END_IF
            IF stateTimout.Q THEN
                stateTimout(IN:= FALSE);
                OpState:= E_RotationBrakeCheckerState.Error;
                sErrorMessage:= 'AXIS STO';
			END_IF
            
        E_RotationBrakeCheckerState.Enable_Motor:
            ManualReleaseBrake1:= FALSE;
            ManualReleaseBrake2:= FALSE;
            stateTimout(IN:= TRUE, PT:=T#2S);
            astAxes[AXIS_ROTATION].stControl.bEnable:= TRUE;
            
            IF astAxes[AXIS_ROTATION].stStatus.bEnabled THEN
                stateTimout(IN:= FALSE);
                OpState:= E_RotationBrakeCheckerState.Wait_For_Test_Trigger;
			END_IF
            IF stateTimout.Q THEN
                stateTimout(IN:= FALSE);
                OpState:= E_RotationBrakeCheckerState.Error;
                sErrorMessage:= 'Axis could not enable';
			END_IF
        
        E_RotationBrakeCheckerState.Wait_For_Test_Trigger:
            IF GVL.astAxes[AXIS_ROTATION].Axis.Status.Error THEN
                GVL_INTER.RESET_ALL:= TRUE;
                ResetCounter:= ResetCounter +1;
                IF ResetCounter>ResetCounterLimit THEN
                    OpState:= E_RotationBrakeCheckerState.Error;
                    sErrorMessage:= 'Axis in error state, cannot be reset';
                END_IF
			END_IF
            astAxes[AXIS_ROTATION].stControl.bEnable:= TRUE;
        //We have an enabled motor, brake mode unlocked, all errors cleared
            ManualReleaseBrake1:= FALSE;
            ManualReleaseBrake2:= FALSE;
            fbAx8000BrakeTest(Axis:= astAxes[AXIS_ROTATION].Axis,
                Execute:= FALSE);
            
            //Does not clear brake test mode (yet?)
            IF FinishBrakeTesting OR NOT bInBrakeTestMode THEN
                OpState:= E_RotationBrakeCheckerState.Finishing_Brake_Test;                
			END_IF
            TestingBrake1:= FALSE;
            TestingBrake2:= FALSE;
            RunBrake1Test:= FALSE;
            RunBrake2Test:= FALSE;
            
            IF TriggerBrake1Test THEN
                TestingBrake1:= TRUE;
                ManualReleaseBrake2:= TRUE;
                OpState:= E_RotationBrakeCheckerState.Brake_Disengage_Delay;
			END_IF
            IF TriggerBrake2Test THEN
                TestingBrake2:= TRUE;
                ManualReleaseBrake1:= TRUE;
                OpState:= E_RotationBrakeCheckerState.Brake_Disengage_Delay;
			END_IF
            
        E_RotationBrakeCheckerState.Brake_Disengage_Delay:
            astAxes[AXIS_ROTATION].stControl.bEnable:= TRUE;
            brakeDelay(IN:= TRUE, PT:=T#1000MS);
            
            //Brake 1 tester
            IF TestingBrake1 AND Brake2State AND brakeDelay.Q THEN
                brakeDelay(IN:= FALSE);
                OpState:= E_RotationBrakeCheckerState.Brake_Test_Triggered;
			END_IF
            
            //Brake 2 tester
            IF TestingBrake2 AND Brake1State AND brakeDelay.Q THEN
                brakeDelay(IN:= FALSE);
                OpState:= E_RotationBrakeCheckerState.Brake_Test_Triggered;
			END_IF
            
        E_RotationBrakeCheckerState.Brake_Test_Triggered:
            astAxes[AXIS_ROTATION].stControl.bEnable:= TRUE;
            loadDelay(IN:= TRUE, PT:=T#500MS);
            timeToClearValid(IN:= TRUE, PT:=T#750MS);
            IF TestingBrake2 THEN
                IF loadDelay.Q THEN
                    RunBrake2Test := TRUE;
				END_IF               
                ManualReleaseBrake2:= FALSE;                
			END_IF
            IF TestingBrake1 THEN
                IF loadDelay.Q THEN
                    RunBrake1Test := TRUE;
				END_IF
                ManualReleaseBrake1:= FALSE;                
			END_IF
            fbAx8000BrakeTest(Axis:= astAxes[AXIS_ROTATION].Axis,
                Execute:= TRUE, 
                Torque:= TEST_TORQUE, 
                VelocityLimit:= 10,
                Succeeded:=FALSE,
                Timeout:= T#10S);
            
            IF timeToClearValid.Q THEN
                loadDelay(IN:= FALSE, PT:=T#500MS);
                timeToClearValid(IN:= FALSE, PT:=T#750MS);
                OpState:= E_RotationBrakeCheckerState.Brake_Testing_Underway;
			END_IF
            
        E_RotationBrakeCheckerState.Brake_Testing_Underway:
            astAxes[AXIS_ROTATION].stControl.bEnable:= TRUE;
            //Ensure only 1 brake released
            IF TestingBrake1 THEN
                fbAx8000BrakeTest.Succeeded:= Brake1Valid;
            ELSIF TestingBrake2 THEN
                fbAx8000BrakeTest.Succeeded:= Brake2Valid;
			END_IF
            
            fbAx8000BrakeTest(Axis:= astAxes[AXIS_ROTATION].Axis,
                Execute:= TRUE);

           IF NOT fbAx8000BrakeTest.Busy AND NOT fbAx8000BrakeTest.Error THEN
               fbAx8000BrakeTest(Axis:= astAxes[AXIS_ROTATION].Axis, Execute:= FALSE);
               OpState:= E_RotationBrakeCheckerState.Wait_For_Test_Trigger;
               RunBrake1Test:=FALSE;
               RunBrake2Test:=FALSE;
               TriggerBrake1Test:= FALSE;
               TriggerBrake2Test:= FALSE;
               loadDelay(IN:= FALSE, PT:=T#500MS);
		   ELSIF NOT fbAx8000BrakeTest.Busy AND fbAx8000BrakeTest.Error THEN
               fbAx8000BrakeTest(Axis:= astAxes[AXIS_ROTATION].Axis, Execute:= FALSE);
               OpState:= E_RotationBrakeCheckerState.Wait_For_Test_Trigger;
               RunBrake1Test:=FALSE;
               RunBrake2Test:=FALSE;
               TriggerBrake1Test:= FALSE;
               TriggerBrake2Test:= FALSE;
               loadDelay(IN:= FALSE, PT:=T#500MS);
            END_IF
        
        E_RotationBrakeCheckerState.Finishing_Brake_Test:
            ManualReleaseBrake1:= FALSE;
            ManualReleaseBrake2:= FALSE;
            
            fbBrakeControl.Execute:= TRUE;
            fbBrakeControl.Mode:= E_AX8000BrakeMode.eAX8000BrakeMode_Automatic;
            fbBrakeControl(Axis:= astAxes[AXIS_ROTATION].Axis);
            
            IF NOT fbBrakeControl.Busy AND NOT fbBrakeControl.Error THEN
                fbBrakeControl.Execute:= FALSE;
                fbBrakeControl.Mode:= E_AX8000BrakeMode.eAX8000BrakeMode_Automatic;
                fbBrakeControl(Axis:= astAxes[AXIS_ROTATION].Axis);
                OpState:= E_RotationBrakeCheckerState.init;
            ELSIF NOT fbBrakeControl.Busy AND fbBrakeControl.Error THEN
                fbBrakeControl.Execute:= FALSE;
                fbBrakeControl.Mode:= E_AX8000BrakeMode.eAX8000BrakeMode_Automatic;
                fbBrakeControl(Axis:= astAxes[AXIS_ROTATION].Axis);
                OpState:= E_RotationBrakeCheckerState.Error;
                sErrorMessage:= 'Unable to set brake mode to automatic whilst performing brake test';
            END_IF
END_CASE
Reinitialise:= FALSE;

]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>