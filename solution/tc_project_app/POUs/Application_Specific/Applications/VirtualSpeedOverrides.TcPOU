<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="VirtualSpeedOverrides" Id="{037162fa-28ac-48d6-8332-0d5fa6b69716}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM VirtualSpeedOverrides
VAR
    i : INT :=0; //iterator for FOR loops
    
    LOCALMODE_SPEED_OVERRIDE : LREAL := 20; //Local mode override of base 20%
    SPEED_OVERRIDE_MODIFIER : LREAL := 1; //Proportional modifier to local mode speed
    
    VerticalOverride : LREAL := 1;
    HorizontalOverride : LREAL := 1;
    RotationOverride : LREAL := 1;
    
    
    
END_VAR
VAR CONSTANT
    VERTICAL_MECHANICAL_LIMIT : LREAL := 28;
    HORIZONTAL_MECHANICAL_LIMIT : LREAL := 5; //Not actually but just no need to be fast
    ROTATION_MECHANICAL_LIMIT : LREAL := 0.65; // Not actually, just a sensible number
    
    VERTICAL_SAFE_LIMIT : LREAL := 5;
    HORIZONTAL_SAFE_LIMIT : LREAL := 5;
    ROTATION_SAFE_LIMIT : LREAL := 0.15;
    
    THRESHOLD : LREAL := 90; //May need to tune this, this'll be the limit we start overriding at so we don't trip the actual mechanical or safe limits
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*Latest thoughts,
K.I.S.S

Look at the setpoint velocities of each real axis
Work out which axis is suffering worse
We can back calculate the original setpoint by dividing throuhgh the override value
We constantly back calculate so we can change the override every cycle

I think we keep the flat local mode speed override - should stop any instantaneous overspeeds I can't catch
But we'll monitor for 80%? within mechanical and safe limits
*)

IF GVL_Safety.UnoccupiedMode THEN   
    //Check vertical axis
    IF (ABS(INTER_LOGIC.axisSpg_Vertical.velocity)/SPEED_OVERRIDE_MODIFIER) > (VERTICAL_MECHANICAL_LIMIT*THRESHOLD) THEN
        VerticalOverride:= (VERTICAL_MECHANICAL_LIMIT*THRESHOLD)/ABS(INTER_LOGIC.axisSpg_Vertical.velocity);
    ELSE
        VerticalOverride:= 1;//No vertical limiting required
	END_IF
    
    //Check horizontal axis
    IF (ABS(INTER_LOGIC.axisSpg_Horizontal.velocity)/SPEED_OVERRIDE_MODIFIER) > (HORIZONTAL_MECHANICAL_LIMIT*THRESHOLD) THEN
        HorizontalOverride:= (HORIZONTAL_MECHANICAL_LIMIT*THRESHOLD)/ABS(INTER_LOGIC.axisSpg_Horizontal.velocity);
    ELSE
        HorizontalOverride:= 1;//No horizontal limiting required
	END_IF
    
    //Check rotation axis
    IF (ABS(INTER_LOGIC.axisSpg_Rot.velocity)/SPEED_OVERRIDE_MODIFIER) > (ROTATION_MECHANICAL_LIMIT*THRESHOLD) THEN
        RotationOverride:= (ROTATION_MECHANICAL_LIMIT*THRESHOLD)/ABS(INTER_LOGIC.axisSpg_Rot.velocity);
    ELSE
        RotationOverride:= 1;//No rotation limiting required
	END_IF
        
    SPEED_OVERRIDE_MODIFIER:= MIN(VerticalOverride, HorizontalOverride, RotationOverride);  //Take the worst case scenario
    
    FOR i:=1 TO INTER_LOGIC.ARRAYSIZE_ALLVIRTUALS DO
        astAxes[INTER_LOGIC.aVirtualAxisDefaults[i].axisID].stConfig.fOverride := 100* SPEED_OVERRIDE_MODIFIER;
        GVL_INTER.SPEED_LIMITING:= FALSE;
	END_FOR

ELSE
    //LOW SPEED MODE
    
    //Unsure on this maths, the spgs are created from the axes that will have by default had a 20% speed override applied, so I don't need to use that in initial caluclation?
    IF (ABS(INTER_LOGIC.axisSpg_Vertical.velocity)/(SPEED_OVERRIDE_MODIFIER) > (VERTICAL_SAFE_LIMIT*THRESHOLD)) THEN
        VerticalOverride:= (VERTICAL_SAFE_LIMIT*THRESHOLD)/(ABS(INTER_LOGIC.axisSpg_Vertical.velocity));
    ELSE
        VerticalOverride:= 1;//No vertical limiting required
	END_IF
    
    IF (ABS(INTER_LOGIC.axisSpg_Horizontal.velocity)/(SPEED_OVERRIDE_MODIFIER)) > (HORIZONTAL_SAFE_LIMIT*THRESHOLD) THEN
        HorizontalOverride:= (HORIZONTAL_SAFE_LIMIT*THRESHOLD)/(ABS(INTER_LOGIC.axisSpg_Horizontal.velocity));
    ELSE
        HorizontalOverride:= 1;//No vertical limiting required
	END_IF
    
    IF (ABS(INTER_LOGIC.axisSpg_Rot.velocity)/(SPEED_OVERRIDE_MODIFIER)) > (ROTATION_SAFE_LIMIT*THRESHOLD) THEN
        RotationOverride:= (ROTATION_SAFE_LIMIT*THRESHOLD)/(ABS(INTER_LOGIC.axisSpg_Rot.velocity)); //*LOCALMODE_SPEED_OVERRIDE was removed from all of these for similar reasons, it should already be applied
    ELSE
        RotationOverride:= 1;//No vertical limiting required
	END_IF       
    
    SPEED_OVERRIDE_MODIFIER:= MIN(VerticalOverride, HorizontalOverride, RotationOverride);  //Take the worst case scenario
    
    FOR i:=1 TO INTER_LOGIC.ARRAYSIZE_ALLVIRTUALS DO
        astAxes[INTER_LOGIC.aVirtualAxisDefaults[i].axisID].stConfig.fOverride := LOCALMODE_SPEED_OVERRIDE * SPEED_OVERRIDE_MODIFIER;
        GVL_INTER.SPEED_LIMITING:= TRUE;
	END_FOR
END_IF



//HIGH SPEED
    //MEASUREMENT AXIS valid at 0.65 degs/s  
    //Verts max at 27.5
    //Rot at 0.65
    //Hor at 1.3
    //




(*
//Check speeds not too high
IF NOT GVL_INTER.SPEED_LIMITING AND (ABS(axisSpg_Vertical.velocity)>VERTICAL_SPEED_LIMIT OR ABS(axisSpg_Horizontal.velocity)>HORIZONTAL_SPEED_LIMIT OR ABS(axisSpg_Rot.velocity)>ROTATION_SPEED_LIMIT) THEN
    IF axisSpg_Vertical.velocity>0 THEN
        axisSpg_Vertical.velocity:= VERTICAL_SPEED_LIMIT;
    ELSE
        axisSpg_Vertical.velocity:= -VERTICAL_SPEED_LIMIT;
    END_IF    
    
    IF axisSpg_Horizontal.velocity>0 THEN
        axisSpg_Horizontal.velocity:= HORIZONTAL_SPEED_LIMIT;
    ELSE
        axisSpg_Horizontal.velocity:= -HORIZONTAL_SPEED_LIMIT;
    END_IF 
    
     IF axisSpg_Rot.velocity>0 THEN
        axisSpg_Rot.velocity:= ROTATION_SPEED_LIMIT;
    ELSE
        axisSpg_Rot.velocity:= -ROTATION_SPEED_LIMIT;
    END_IF 

    FOR i:=1 TO ARRAYSIZE_ALLVIRTUALS DO
        astAxes[aVirtualAxisDefaults[i].axisID].stConfig.fOverride := 20;
        GVL_INTER.SPEED_LIMITING:= TRUE;
	END_FOR
END_IF
//We have stopped moving so can stop speed limiting
IF GVL_INTER.VIRTUAL_AXES_NOT_MOVING AND GVL_INTER.SPEED_LIMITING THEN
    FOR i:=1 TO ARRAYSIZE_ALLVIRTUALS DO
        astAxes[aVirtualAxisDefaults[i].axisID].stConfig.fOverride := 100;
        GVL_INTER.SPEED_LIMITING:= FALSE;
	END_FOR
END_IF
*)]]></ST>
    </Implementation>
    <LineIds Name="VirtualSpeedOverrides">
      <LineId Id="6" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="162" Count="0" />
      <LineId Id="161" Count="0" />
      <LineId Id="164" Count="0" />
      <LineId Id="163" Count="0" />
      <LineId Id="167" Count="1" />
      <LineId Id="160" Count="0" />
      <LineId Id="169" Count="0" />
      <LineId Id="151" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="189" Count="0" />
      <LineId Id="196" Count="0" />
      <LineId Id="192" Count="0" />
      <LineId Id="194" Count="1" />
      <LineId Id="193" Count="0" />
      <LineId Id="190" Count="1" />
      <LineId Id="198" Count="3" />
      <LineId Id="197" Count="0" />
      <LineId Id="202" Count="0" />
      <LineId Id="205" Count="4" />
      <LineId Id="203" Count="1" />
      <LineId Id="188" Count="0" />
      <LineId Id="210" Count="0" />
      <LineId Id="16" Count="3" />
      <LineId Id="213" Count="0" />
      <LineId Id="20" Count="1" />
      <LineId Id="238" Count="1" />
      <LineId Id="223" Count="3" />
      <LineId Id="216" Count="1" />
      <LineId Id="227" Count="3" />
      <LineId Id="218" Count="1" />
      <LineId Id="231" Count="3" />
      <LineId Id="220" Count="0" />
      <LineId Id="236" Count="0" />
      <LineId Id="222" Count="0" />
      <LineId Id="237" Count="0" />
      <LineId Id="22" Count="7" />
      <LineId Id="183" Count="4" />
      <LineId Id="30" Count="2" />
      <LineId Id="61" Count="34" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>