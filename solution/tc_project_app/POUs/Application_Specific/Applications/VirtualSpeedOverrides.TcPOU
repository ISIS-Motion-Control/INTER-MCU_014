<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="VirtualSpeedOverrides" Id="{11418889-a1eb-48c8-ab23-882e0dbec13a}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM VirtualSpeedOverrides
VAR
    i : INT :=0; //iterator for FOR loops
    
    LOCALMODE_SPEED_OVERRIDE : LREAL := 18; //Local mode override of base 20%
    SPEED_OVERRIDE_MODIFIER : LREAL := 1; //Proportional modifier to local mode speed
    
    VerticalOverride : LREAL := 1;
    HorizontalOverride : LREAL := 1;
    RotationOverride : LREAL := 1;
    
    bTest : BOOL;
    
END_VAR
VAR CONSTANT
    VERTICAL_MECHANICAL_LIMIT : LREAL := 28;
    HORIZONTAL_MECHANICAL_LIMIT : LREAL := 5; //Not actually but just no need to be fast
    ROTATION_MECHANICAL_LIMIT : LREAL := 0.65; // Not actually, just a sensible number
    
    VERTICAL_SAFE_LIMIT : LREAL := 5;
    HORIZONTAL_SAFE_LIMIT : LREAL := 5;
    ROTATION_SAFE_LIMIT : LREAL := 0.15;
    
    
    
    THRESHOLD : LREAL := 0.8; //May need to tune this, this'll be the limit we start overriding at so we don't trip the actual mechanical or safe limits
    NON_LINEAR_FUDGE_FACTOR :LREAL := 0.75;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*Latest thoughts,
K.I.S.S

Look at the setpoint velocities of each real axis
Work out which axis is suffering worse
We can back calculate the original setpoint by dividing throuhgh the override value
We constantly back calculate so we can change the override every cycle

I think we keep the flat local mode speed override - should stop any instantaneous overspeeds I can't catch
But we'll monitor for 80%? within mechanical and safe limits
*)

IF GVL_Safety.UnoccupiedMode THEN   
    //Check vertical axis
    IF (ABS(INTER_LOGIC.axisSpg_Vertical.velocity)) > (VERTICAL_MECHANICAL_LIMIT*THRESHOLD) THEN
        VerticalOverride:= ((VERTICAL_MECHANICAL_LIMIT*THRESHOLD)/ABS(INTER_LOGIC.axisSpg_Vertical.velocity))*NON_LINEAR_FUDGE_FACTOR;
    ELSE
        VerticalOverride:= 1;//No vertical limiting required
	END_IF
    
    //Check horizontal axis
    IF (ABS(INTER_LOGIC.axisSpg_Horizontal.velocity)) > (HORIZONTAL_MECHANICAL_LIMIT*THRESHOLD) THEN
        HorizontalOverride:= ((HORIZONTAL_MECHANICAL_LIMIT*THRESHOLD)/ABS(INTER_LOGIC.axisSpg_Horizontal.velocity))*NON_LINEAR_FUDGE_FACTOR;
    ELSE
        HorizontalOverride:= 1;//No horizontal limiting required
	END_IF
    
    //Check rotation axis
    IF (ABS(INTER_LOGIC.axisSpg_Rot.velocity)) > (ROTATION_MECHANICAL_LIMIT*THRESHOLD) THEN
        RotationOverride:= (ROTATION_MECHANICAL_LIMIT*THRESHOLD)/ABS(INTER_LOGIC.axisSpg_Rot.velocity);
    ELSE
        RotationOverride:= 1;//No rotation limiting required
	END_IF
        
    SPEED_OVERRIDE_MODIFIER:= MIN(VerticalOverride, HorizontalOverride, RotationOverride);  //Take the worst case scenario
    
    FOR i:=1 TO INTER_LOGIC.ARRAYSIZE_ALLVIRTUALS DO
        astAxes[INTER_LOGIC.aVirtualAxisDefaults[i].axisID].stConfig.fOverride := 100* SPEED_OVERRIDE_MODIFIER;
        
	END_FOR
    FOR i:=1 TO 3 DO
        astAxes[AXIS_COMBINED_VERTICAL].stConfig.fOverride := 100;
        astAxes[AXIS_ROTATION].stConfig.fOverride := 100;
        astAxes[AXIS_HORIZONTAL_TRANSLATION].stConfig.fOverride := 100;
	END_FOR

ELSE
    //LOW SPEED MODE
    FOR i:=1 TO 3 DO
        astAxes[AXIS_COMBINED_VERTICAL].stConfig.fOverride := LOCALMODE_SPEED_OVERRIDE;
        astAxes[AXIS_ROTATION].stConfig.fOverride :=LOCALMODE_SPEED_OVERRIDE;
        astAxes[AXIS_HORIZONTAL_TRANSLATION].stConfig.fOverride := LOCALMODE_SPEED_OVERRIDE;
	END_FOR
    //Unsure on this maths, the spgs are created from the axes that will have by default had a 20% speed override applied, so I don't need to use that in initial caluclation?
    IF (ABS(INTER_LOGIC.axisSpg_Vertical.velocity)) > (VERTICAL_SAFE_LIMIT*THRESHOLD) THEN
        VerticalOverride:= ((VERTICAL_SAFE_LIMIT*THRESHOLD)/(ABS(INTER_LOGIC.axisSpg_Vertical.velocity)))*NON_LINEAR_FUDGE_FACTOR;
        bTest := TRUE;
    ELSE
        VerticalOverride:= 1;//No vertical limiting required
        bTest := FALSE;
	END_IF
    
    IF (ABS(INTER_LOGIC.axisSpg_Horizontal.velocity)) > (HORIZONTAL_SAFE_LIMIT*THRESHOLD) THEN
        HorizontalOverride:= ((HORIZONTAL_SAFE_LIMIT*THRESHOLD)/(ABS(INTER_LOGIC.axisSpg_Horizontal.velocity)))*NON_LINEAR_FUDGE_FACTOR;
    ELSE
        HorizontalOverride:= 1;//No vertical limiting required
	END_IF
    
    IF (ABS(INTER_LOGIC.axisSpg_Rot.velocity)) > (ROTATION_SAFE_LIMIT*THRESHOLD) THEN
        RotationOverride:= (ROTATION_SAFE_LIMIT*THRESHOLD)/(ABS(INTER_LOGIC.axisSpg_Rot.velocity)); //*LOCALMODE_SPEED_OVERRIDE was removed from all of these for similar reasons, it should already be applied
    ELSE
        RotationOverride:= 1;//No vertical limiting required
	END_IF       
    
    SPEED_OVERRIDE_MODIFIER:= MIN(VerticalOverride, HorizontalOverride, RotationOverride);  //Take the worst case scenario
    
    FOR i:=1 TO INTER_LOGIC.ARRAYSIZE_ALLVIRTUALS DO
        astAxes[INTER_LOGIC.aVirtualAxisDefaults[i].axisID].stConfig.fOverride := LOCALMODE_SPEED_OVERRIDE * SPEED_OVERRIDE_MODIFIER;
        GVL_INTER.SPEED_LIMITING:= TRUE;
	END_FOR
END_IF

IF SPEED_OVERRIDE_MODIFIER < 1 THEN
    GVL_INTER.SPEED_LIMITING:= TRUE;
ELSE
    GVL_INTER.SPEED_LIMITING:= FALSE;
END_IF
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>