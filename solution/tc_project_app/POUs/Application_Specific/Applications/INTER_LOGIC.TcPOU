<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="INTER_LOGIC" Id="{da89d596-93f4-468f-9a43-1a72f2055b25}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM INTER_LOGIC
VAR
    NcAxisError : BOOL;
    LogicError : BOOL;
    
    decoupleVerticalMotion : BOOL := FALSE;
    
    safetyFTrig : F_TRIG;
    safetyResetTON : TON;
    safetyResetLatch : BOOL :=FALSE;
    
    
    CombinedVerticalSetupComplete : BOOL := FALSE;
    AllowedVerticalLag : LREAL := 0.2;  //How much offset is allowed between two vertical axes when synced
    VerticalAxesCalibrated : BOOL := FALSE;
    VerticalAxesSpgEnabled : BOOL := FALSE;
    
    verticalZ1SpgEnable : MC_ExtSetPointGenEnable;
    verticalZ1SpgDisable : MC_ExtSetPointGenDisable;
    verticalZ2SpgEnable : MC_ExtSetPointGenEnable;
    verticalZ2SpgDisable : MC_ExtSetPointGenDisable;
    
    
    combinedVerticalSetPos : MC_SetPosition();
    
    eStateVertical : eState_Vertical := eState_Vertical.init;
    fVerticalSimulatedDeviation : LREAL;
    fVerticalSimulatedDeviationAllowed : LREAL := 0.1;
    confirmSpgTimeout : TON;
    
    tempZ1Power : MC_Power;
    tempZ2Power : MC_Power;
    
    fZ1SetPos : LREAL;
    fZ1SetVelo : LREAL;
    fZ2SetPos : LREAL;
    fZ2SetVelo : LREAL;
    fZ1SetDir : DINT;
    fZ2SetDir : DINT;
    combinedVerticalDirection : DINT;
    
    
//STUPID DEMO CODE
    Y1rTrig : R_TRIG;
    cycleCounter : LREAL:=0; 
    scalingActive : BOOL := FALSE;   
    
    
    //////////////////////////////////////////////////
    fbSPG_Y_Enable : MC_ExtSetPointGenEnable;
    fbSPG_Y_Disable : MC_ExtSetPointGenDisable;
    fbSPG_Z_Enable : MC_ExtSetPointGenEnable;
    fbSPG_Z_Disable : MC_ExtSetPointGenDisable;
    fbSPG_Rot_Enable : MC_ExtSetPointGenEnable;
    fbSPG_Rot_Disable : MC_ExtSetPointGenDisable;
    enableSPGs : BOOL;
    disableSPGs : BOOL;
    
    yDir : DINT;
    zDir : DINT;
    rotDir :DINT;
    
    /////////////////////////
    eStateInter : eState_INTER := eState_INTER.init;
    checkFirstCycle : BOOL;
    posDevZ : LREAL;
    posDevY : LREAL;
    posDevRot : LREAL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF GVL_INTER.ENABLE_ALL_AXES THEN
    EnableAxes();
END_IF

IF GVL_INTER.DISABLE_ALL_AXES THEN
    DisableAxes();
END_IF

//SAFETY RESET LOGIC (RESET AXES ON ESTOP RESET)
safetyFTrig(CLK:= GVL_Safety.SafetyReset);
IF safetyFTrig.Q THEN
    safetyResetLatch := TRUE;
END_IF

safetyResetTON(IN:= safetyResetLatch, PT:=T#1S);

IF safetyResetTON.Q THEN
    safetyResetLatch:= FALSE;
    GVL_INTER.RESET_ALL := TRUE;
END_IF

IF GVL_INTER.RESET_ALL THEN
    ResetAll();
END_IF

//Check for errors at NC level
NcAxisError := CheckNcErrors();
VerticalAxesCalibrated := CheckVerticalCalibration();
VerticalAxesSpgEnabled := CheckZSpgStatus();




(* Current thoughts,
Not sure I like the combined vertical axis, seems to add more hassle than it's worth as I have to set the position and such.
however, would be easier to link in a fail safe such that if mismatch between Z1 and Z2 position, then kill the enable/motion
Probably should progress with this route.
Also having to run the PLC to match NC cycle time otherwise position loop gets LOUD
Priority for next task:
Sort out the position mismatch fail safe AND monitor to ensure both axes are functional before allowing combined Z to move
MULTIPLE LAYERS OF FAILSAFE for synchronisation
Also setup the state logic for the setpoint generator of the Z
needs to handle the axes initially being in error before STO cleared, handle position setting,
Exiting this coupling for maintenance (tweaking of position)
And what happens when something falls over

*)
CombinedVerticalSetupComplete := FALSE;
IF GVL_INTER.RUN_COUPLED_VERTICAL THEN
    ////////////// RUN ALL THE TIME ///////////////////////////////////////        
    //Enable linking
    IF astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bEnabled AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bEnabled THEN
        //Only enable virtual axis if both RAW axes are homed/calibrated
        IF VerticalAxesCalibrated AND  VerticalAxesSpgEnabled AND NOT (astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bError OR astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bError)THEN
            astAxes[AXIS_COMBINED_VERTICAL].stControl.bEnable := TRUE;
        ELSE 
            astAxes[AXIS_COMBINED_VERTICAL].stControl.bEnable := FALSE;
		END_IF
	END_IF
    
    //Fwd limit linking
    astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitFwd := (astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitFwd AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitFwd);
    //Bwd limit linking
    astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitBwd := (astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitBwd AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd);
    
    //OVERRIDE LIMITS
    IF NOT decoupleVerticalMotion THEN
        astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitFwd := TRUE;
        astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitBwd := TRUE;
        astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitFwd := TRUE;
        astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd := TRUE;
	END_IF
    
    fVerticalSimulatedDeviation := astAxes[AXIS_COMBINED_VERTICAL].stStatus.fActPosition - astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.fActPosition;
    
    confirmSpgTimeout(PT:=T#1S);
    /////////////////////////////////////////////////////////////////////
    
    IF astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bError OR astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bError THEN
        eStateVertical:= eState_Vertical.init;
	END_IF
    
    actSyncVertStateMachine();
        
END_IF

combinedVerticalSetPos(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis);
combinedVerticalSetPos.Execute:= FALSE;

IF(astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.ActVelo>0) THEN
    combinedVerticalDirection := 1;
ELSIF (astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.ActVelo<0) THEN
    combinedVerticalDirection := -1;
ELSE 
    combinedVerticalDirection := 0;
END_IF

actZSetpoints();
verticalZ1SpgEnable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis);
verticalZ1SpgEnable.Execute:= FALSE;
verticalZ1SpgDisable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis);
verticalZ1SpgDisable.Execute:= FALSE;
verticalZ2SpgEnable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis);
verticalZ2SpgEnable.Execute:= FALSE;
verticalZ2SpgDisable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis);
verticalZ2SpgDisable.Execute:= FALSE;





/////////////////////////////////ACTUAL LOGIC/////////////////////////////////////////
actCheckPositionDeviation();

//DISABLE AXES (overridden if operational)
astAxes[AXIS_MEASUREMENT_ANGLE].stControl.bEnable := FALSE;

IF CombinedVerticalSetupComplete AND GVL_INTER.RUN_KINEMATICS THEN
    
    CASE eStateInter OF
        eState_INTER.init:
            IF ABS(posDevZ)<0.1 AND ABS(posDevY)<0.1 AND ABS(posDevRot)<0.05 THEN
                eStateInter:= eState_INTER.enableSPG;
            ELSE
                eStateInter:= eState_INTER.goToNeutral;
			END_IF
            
            
        eState_INTER.goToNeutral:
            //Send axes to default positions
            //Send real axes to where they would be if SPG'd
            //TO DO = SETUP DEFAULT VELOCITY SO DON'T NEED TO BE CALLED HERE
            astAxes[AXIS_HORIZONTAL_TRANSLATION].stControl.eCommand:= E_MotionFunctions.eMoveAbsolute;
            astAxes[AXIS_HORIZONTAL_TRANSLATION].stControl.fPosition:= astAxes[AXIS_HORIZONTAL_VIRTUAL].stStatus.fActPosition + astAxes[AXIS_HORIZONTAL_SAMPLE].stStatus.fActPosition + astAxes[AXIS_HORIZONTAL_CALIBRATION].stStatus.fActPosition;
            astAxes[AXIS_HORIZONTAL_TRANSLATION].stControl.fVelocity :=20;
            astAxes[AXIS_HORIZONTAL_TRANSLATION].stControl.bExecute:= TRUE;
            
            astAxes[AXIS_COMBINED_VERTICAL].stControl.eCommand:= E_MotionFunctions.eMoveAbsolute;
            astAxes[AXIS_COMBINED_VERTICAL].stControl.fPosition:= astAxes[AXIS_COMBINED_VERTICAL_VIRTUAL].stStatus.fActPosition + astAxes[AXIS_COMBINED_VERTICAL_SAMPLE].stStatus.fActPosition + astAxes[AXIS_COMBINED_VERTICAL_CALIBRATION].stStatus.fActPosition;
            astAxes[AXIS_COMBINED_VERTICAL].stControl.fVelocity :=20;
            astAxes[AXIS_COMBINED_VERTICAL].stControl.bExecute:= TRUE;
            
            astAxes[AXIS_ROTATION].stControl.eCommand:= E_MotionFunctions.eMoveAbsolute;
            astAxes[AXIS_ROTATION].stControl.fPosition:= astAxes[AXIS_ROTATION_VIRTUAL].stStatus.fActPosition + astAxes[AXIS_ROTATION_SAMPLE].stStatus.fActPosition + astAxes[AXIS_ROTATION_CALIBRATION].stStatus.fActPosition;
            astAxes[AXIS_ROTATION].stControl.fVelocity :=1;
            astAxes[AXIS_ROTATION].stControl.bExecute:= TRUE;
            eStateInter:= eState_INTER.CheckNeutral;
            
        eState_INTER.CheckNeutral:
            IF checkFirstCycle THEN
                //Move check and position check
                IF astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis.Status.NotMoving AND astAxes[AXIS_COMBINED_VERTICAL].Axis.Status.NotMoving AND astAxes[AXIS_ROTATION].Axis.Status.NotMoving THEN
                    IF ABS(posDevZ)<0.1 AND ABS(posDevY)<0.1 AND ABS(posDevRot)<0.05 THEN
                        //WE ARE IN CORRECT POSITION
                        checkFirstCycle := FALSE;
                        eStateInter:= eState_INTER.enableSPG;
					END_IF                    
				END_IF
                
            ELSE
                checkFirstCycle:= TRUE;
			END_IF
            
        eState_INTER.enableSPG:
            fbSPG_Y_Enable.Execute:= TRUE;
            fbSPG_Z_Enable.Execute:= TRUE;
            fbSPG_Rot_Enable.Execute:= TRUE;
            eStateInter:= eState_INTER.checkEnableSPG;
           
        eState_INTER.checkEnableSPG:
            IF astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis.Status.ExtSetPointGenEnabled AND astAxes[AXIS_COMBINED_VERTICAL].Axis.Status.ExtSetPointGenEnabled AND astAxes[AXIS_ROTATION].Axis.Status.ExtSetPointGenEnabled THEN
                eStateInter :=eState_INTER.operation;
			END_IF
        
        eState_INTER.operation:
            //IN HERE WE WILL CHECK SPGs STAY ENABLED AND ENABLE THE VIRTUAL AXES - to be completed
            IF NOT NcAxisError THEN
                IF astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis.Status.ExtSetPointGenEnabled AND astAxes[AXIS_COMBINED_VERTICAL].Axis.Status.ExtSetPointGenEnabled AND astAxes[AXIS_ROTATION].Axis.Status.ExtSetPointGenEnabled THEN
                    astAxes[AXIS_MEASUREMENT_ANGLE].stControl.bEnable := TRUE;
			    END_IF
            END_IF
            
	END_CASE
    
    
    //TO BE DELETED - test code
    IF enableSPGs THEN
        fbSPG_Y_Enable.Execute:= TRUE;
        fbSPG_Z_Enable.Execute:= TRUE;
        fbSPG_Rot_Enable.Execute:= TRUE;
        enableSPGs := FALSE;
	END_IF
    
    IF disableSPGs THEN
        fbSPG_Y_Disable.Execute:= TRUE;
        fbSPG_Z_Disable.Execute:= TRUE;
        fbSPG_Rot_Disable.Execute:= TRUE;
        disableSPGs := FALSE;
	END_IF
    
END_IF

//SPG DIRECTION CHECK LOGIC
IF astAxes[AXIS_HORIZONTAL_VIRTUAL].Axis.NcToPlc.ActVelo>0 THEN
    zDir := 1;
ELSIF astAxes[AXIS_HORIZONTAL_VIRTUAL].Axis.NcToPlc.ActVelo<0 THEN
    zDir := -1;
ELSE
    zDir := 0;
END_IF

IF astAxes[AXIS_COMBINED_VERTICAL_VIRTUAL].Axis.NcToPlc.ActVelo>0 THEN
    yDir := 1;
ELSIF astAxes[AXIS_COMBINED_VERTICAL_VIRTUAL].Axis.NcToPlc.ActVelo<0 THEN
    yDir := -1;
ELSE
    yDir := 0;
END_IF
IF astAxes[AXIS_ROTATION_VIRTUAL].Axis.NcToPlc.ActVelo>0 THEN
    rotDir := 1;
ELSIF astAxes[AXIS_ROTATION_VIRTUAL].Axis.NcToPlc.ActVelo<0 THEN
    rotDir := -1;
ELSE
    rotDir := 0;
END_IF
//////

//SPG CALLS
MC_ExtSetPointGenFeed(Axis:= astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis, 
        Position:= astAxes[AXIS_HORIZONTAL_VIRTUAL].Axis.NcToPlc.ActPos,
        Velocity:=astAxes[AXIS_HORIZONTAL_VIRTUAL].Axis.NcToPlc.ActVelo,
        Direction:= zDir, Acceleration:= 0);
        
MC_ExtSetPointGenFeed(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis, 
        Position:= astAxes[AXIS_COMBINED_VERTICAL_VIRTUAL].Axis.NcToPlc.ActPos,
        Velocity:=astAxes[AXIS_COMBINED_VERTICAL_VIRTUAL].Axis.NcToPlc.ActVelo,
        Direction:= yDir, Acceleration:= 0);

MC_ExtSetPointGenFeed(Axis:= astAxes[AXIS_ROTATION].Axis, 
        Position:= astAxes[AXIS_ROTATION_VIRTUAL].Axis.NcToPlc.ActPos,
        Velocity:=astAxes[AXIS_ROTATION_VIRTUAL].Axis.NcToPlc.ActVelo,
        Direction:= rotDir, Acceleration:= 0);

fbSPG_Y_Enable(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis);
fbSPG_Y_Disable(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis);
fbSPG_Z_Enable(Axis:=astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis);
fbSPG_Z_Disable(Axis:=astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis);
fbSPG_Rot_Enable(Axis:=astAxes[AXIS_ROTATION].Axis);
fbSPG_Rot_Disable(Axis:=astAxes[AXIS_ROTATION].Axis);

fbSPG_Y_Enable.Execute:= FALSE;
fbSPG_Y_Disable.Execute:= FALSE;
fbSPG_Z_Enable.Execute:= FALSE;
fbSPG_Z_Disable.Execute:= FALSE;
fbSPG_Rot_Enable.Execute:= FALSE;
fbSPG_Rot_Disable.Execute:= FALSE;]]></ST>
    </Implementation>
    <Action Name="actCheckPositionDeviation" Id="{48a3beaa-86d1-4929-b3bc-c17d3fe46a74}">
      <Implementation>
        <ST><![CDATA[posDevZ:=    astAxes[AXIS_HORIZONTAL_TRANSLATION].stStatus.fActPosition - (astAxes[AXIS_HORIZONTAL_VIRTUAL].stStatus.fActPosition + astAxes[AXIS_HORIZONTAL_SAMPLE].stStatus.fActPosition + astAxes[AXIS_HORIZONTAL_CALIBRATION].stStatus.fActPosition);
posDevY:=    astAxes[AXIS_COMBINED_VERTICAL].stStatus.fActPosition - (astAxes[AXIS_COMBINED_VERTICAL_VIRTUAL].stStatus.fActPosition + astAxes[AXIS_COMBINED_VERTICAL_SAMPLE].stStatus.fActPosition + astAxes[AXIS_COMBINED_VERTICAL_CALIBRATION].stStatus.fActPosition);
posDevRot:=    astAxes[AXIS_ROTATION].stStatus.fActPosition - (astAxes[AXIS_ROTATION_VIRTUAL].stStatus.fActPosition + astAxes[AXIS_ROTATION_SAMPLE].stStatus.fActPosition + astAxes[AXIS_ROTATION_CALIBRATION].stStatus.fActPosition);]]></ST>
      </Implementation>
    </Action>
    <Action Name="actSyncVertStateMachine" Id="{86ee614e-4a39-40bc-bbfb-49053b8e3adf}">
      <Implementation>
        <ST><![CDATA[CASE eStateVertical OF
        eState_Vertical.init:
            IF NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bError AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bError THEN
                IF NOT decoupleVerticalMotion THEN
                    eStateVertical := eState_Vertical.checkPosition;
                END_IF
			END_IF
            
        eState_Vertical.checkPosition:
            //Assume Z1 and Z2 calibrated to be at same position
            IF ABS(fVerticalSimulatedDeviation)> fVerticalSimulatedDeviationAllowed THEN
                eStateVertical := eState_Vertical.setPosition; //should be setPosition state
            ELSE
                eStateVertical := eState_Vertical.enableSpg;
			END_IF
            
        eState_Vertical.setPosition:
            combinedVerticalSetPos.Position:= astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.fActPosition;
            combinedVerticalSetPos.Execute:= TRUE;
            eStateVertical := eState_Vertical.checkPosition;
            
        eState_Vertical.enableSpg:
            IF astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitBwd AND astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitFwd THEN
                verticalZ1SpgEnable.Execute := TRUE;
                verticalZ2SpgEnable.Execute := TRUE;
                eStateVertical := eState_Vertical.confirmEnableSpg;
            ELSE
                tempZ1Power(Axis:= astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis, Enable:= TRUE, Enable_Negative:=TRUE, Enable_Positive:=TRUE);
			    tempZ2Power(Axis:= astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis, Enable:= TRUE, Enable_Negative:=TRUE, Enable_Positive:=TRUE);
                verticalZ1SpgEnable.Execute := TRUE;
                verticalZ2SpgEnable.Execute := TRUE;
                eStateVertical := eState_Vertical.confirmEnableSpg;
            END_IF
            
        
        eState_Vertical.confirmEnableSpg:
            confirmSpgTimeout.IN:= TRUE;
            //Timeout check
            IF confirmSpgTimeout.Q THEN
                confirmSpgTimeout.IN:= FALSE;
                eStateVertical := eState_Vertical.init;
			END_IF
            IF VerticalAxesSpgEnabled THEN
                eStateVertical := eState_Vertical.operation;
			END_IF
        
        eState_Vertical.operation:
            //DO NOTHING
            CombinedVerticalSetupComplete := TRUE;
            IF NOT VerticalAxesSpgEnabled THEN
                eStateVertical:= eState_Vertical.init;
			END_IF
            IF decoupleVerticalMotion THEN
                eStateVertical := eState_Vertical.disableSpg;
			END_IF
            
        eState_Vertical.disableSpg:
            verticalZ1SpgDisable.Execute:= TRUE;
            verticalZ2SpgDisable.Execute:= TRUE;
            eStateVertical := eState_Vertical.confirmDisableSpg;
            
        eState_Vertical.confirmDisableSpg:
            IF NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.Status.ExtSetPointGenEnabled AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.Status.ExtSetPointGenEnabled THEN
                eStateVertical := eState_Vertical.init;
            ELSE
                eStateVertical := eState_Vertical.disableSpg;
			END_IF
            
	END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="actZSetpoints" Id="{facf07a9-589c-4d38-a5b7-e5a598ba95ba}">
      <Implementation>
        <ST><![CDATA[astAxes[AXIS_COMBINED_VERTICAL].Axis.ReadStatus();
astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.ReadStatus();
astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.ReadStatus();


//If still getting issues after setting up position and velocity control loops correctly
//expose feedback 1 velocity using PDO assignment at drive and then do comparator against this value
//before sending setpoint generator positions

Y1rTrig(CLK:= astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd);

IF(Y1rTrig.Q) THEN
    scalingActive := TRUE;
END_IF
IF scalingActive THEN
    cycleCounter:= cycleCounter+1;
END_IF
IF cycleCounter>500 THEN
    scalingActive := FALSE;
    cycleCounter:=0;
END_IF
//astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd:= TRUE;

//Z1 position check
IF ((astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos < astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos+0.01)OR (astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo<0)) 
    
    AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd THEN
    //ADSLOGSTR(msgCtrlMask:= ADSLOG_MSGTYPE_HINT,msgFmtStr:='HIT',strArg:='');
    fZ1SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ1SetVelo :=0;
    fZ1SetDir := 0;
ELSIF astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos > astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitFwd THEN
    fZ1SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ1SetVelo :=0;
    fZ1SetDir := 0;
ELSE
    IF scalingActive THEN
        fZ1SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
        fZ1SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo * (0.002*cycleCounter);
        fZ1SetDir := combinedVerticalDirection;
    ELSE
        fZ1SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
        fZ1SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo;
        fZ1SetDir := combinedVerticalDirection;
	END_IF
    //fZ1SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
    //fZ1SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo;
    //fZ1SetDir := combinedVerticalDirection;
END_IF

//Z2 position check
IF astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos < astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitBwd THEN
    fZ2SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ2SetVelo :=0;
    fZ2SetDir := 0;
ELSIF astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos > astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitFwd THEN
    fZ2SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ2SetVelo :=0;
    fZ2SetDir := 0;
ELSE
    fZ2SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
    fZ2SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo;
    fZ2SetDir := combinedVerticalDirection;
END_IF

MC_ExtSetPointGenFeed(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis, Position:= fZ1SetPos, Velocity:= fZ1SetVelo, Acceleration:= 0, Direction:= fZ1SetDir);
MC_ExtSetPointGenFeed(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis, Position:= fZ2SetPos, Velocity:= fZ2SetVelo, Acceleration:= 0, Direction:= fZ2SetDir);
]]></ST>
      </Implementation>
    </Action>
    <Method Name="CheckNcErrors" Id="{7139bf26-abbf-4cba-b321-d9387e4f0885}">
      <Declaration><![CDATA[METHOD CheckNcErrors : BOOL
VAR_INPUT
END_VAR
VAR
    i : UINT := 5;
    Error : BOOL := FALSE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i :=5 TO GVL_APP.nAXIS_NUM DO
    IF astAxes[i].stStatus.bError THEN
        Error := TRUE;
	END_IF
END_FOR
CheckNcErrors := Error;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckVerticalCalibration" Id="{e1036243-04e4-4263-b466-d17b80a88071}">
      <Declaration><![CDATA[METHOD CheckVerticalCalibration : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CheckVerticalCalibration := astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.Status.Homed AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.Status.Homed;]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckZSpgStatus" Id="{be3f907d-6383-4f00-95cd-2d71447606c2}">
      <Declaration><![CDATA[METHOD CheckZSpgStatus : BOOL
VAR
    SpgSet : BOOL := FALSE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SpgSet := astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.Status.ExtSetPointGenEnabled AND astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.Status.ExtSetPointGenEnabled;
CheckZSpgStatus := SpgSet;]]></ST>
      </Implementation>
    </Method>
    <Method Name="DisableAxes" Id="{445cd5b3-7fd2-4adb-8098-44aeb3439028}">
      <Declaration><![CDATA[METHOD DisableAxes : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[astAxes[AXIS_HORIZONTAL_TRANSLATION].stControl.bEnable :=FALSE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stControl.bEnable :=FALSE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stControl.bEnable :=FALSE;
astAxes[AXIS_ROTATION].stControl.bEnable :=FALSE;
GVL_INTER.DISABLE_ALL_AXES := FALSE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="EnableAxes" Id="{b0c85ed2-0ac0-448f-af10-0513bd266d32}">
      <Declaration><![CDATA[METHOD EnableAxes : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[astAxes[AXIS_HORIZONTAL_TRANSLATION].stControl.bEnable :=TRUE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stControl.bEnable :=TRUE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stControl.bEnable :=TRUE;
astAxes[AXIS_ROTATION].stControl.bEnable :=TRUE;
GVL_INTER.ENABLE_ALL_AXES := FALSE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetAll" Id="{e4647f95-e102-4ec6-b060-9c49e98b19a4}">
      <Declaration><![CDATA[METHOD ResetAll : BOOL
VAR_INPUT
END_VAR

VAR
    i : UINT :=5;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i :=5 TO GVL_APP.nAXIS_NUM DO
        astAxes[i].stControl.bReset:= TRUE;
END_FOR

GVL_INTER.RESET_ALL := FALSE;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>