<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="INTER_LOGIC" Id="{da89d596-93f4-468f-9a43-1a72f2055b25}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM INTER_LOGIC
VAR
    driveStartupDelay : TON;

    LogicError : BOOL;
    
    decoupleVerticalMotion : BOOL := FALSE;
    
    safetyFTrig : F_TRIG;
    safetyResetTON : TON;
    safetyResetLatch : BOOL :=FALSE;
    safetyResetDone: BOOL;
    driveResetDone : BOOL;
    
    
    CombinedVerticalSetupComplete : BOOL := FALSE;
    AllowedVerticalLag : LREAL := 0.2;  //How much offset is allowed between two vertical axes when synced
    VerticalAxesCalibrated : BOOL := FALSE;
    VerticalAxesSpgEnabled : BOOL := FALSE;
    
    verticalZ1SpgEnable : MC_ExtSetPointGenEnable;
    verticalZ1SpgDisable : MC_ExtSetPointGenDisable;
    verticalZ2SpgEnable : MC_ExtSetPointGenEnable;
    verticalZ2SpgDisable : MC_ExtSetPointGenDisable;
    
    
    combinedVerticalSetPos : MC_SetPosition();
    
    eStateVertical : eState_Vertical := eState_Vertical.init;
    fVerticalSimulatedDeviation : LREAL;
    fVerticalSimulatedDeviationAllowed : LREAL := 0.1;
    confirmSpgTimeout : TON;
    
    tempZ1Power : MC_Power;
    tempZ2Power : MC_Power;
    
    fZ1SetPos : LREAL;
    fZ1SetVelo : LREAL;
    fZ2SetPos : LREAL;
    fZ2SetVelo : LREAL;
    fZ1SetDir : DINT;
    fZ2SetDir : DINT;
    combinedVerticalDirection : DINT;
    
    
//STUPID DEMO CODE
    Y1rTrig : R_TRIG;
    cycleCounter : LREAL:=0; 
    scalingActive : BOOL := FALSE;   
    
    
    //////////////////////////////////////////////////
    fbSPG_Y_Enable : MC_ExtSetPointGenEnable;
    fbSPG_Y_Disable : MC_ExtSetPointGenDisable;
    fbSPG_Z_Enable : MC_ExtSetPointGenEnable;
    fbSPG_Z_Disable : MC_ExtSetPointGenDisable;
    fbSPG_Rot_Enable : MC_ExtSetPointGenEnable;
    fbSPG_Rot_Disable : MC_ExtSetPointGenDisable;
    enableSPGs : BOOL;
    disableSPGs : BOOL;
        
    /////////////////////////
    eStateInter : eState_INTER := eState_INTER.init;
    checkFirstCycle : BOOL;
    posDevZ : LREAL;
    posDevY : LREAL;
    posDevRot : LREAL;
    bRealDevValid : BOOL;
    bDefaultDevValid : BOOL;
    bRecoveryDevValid : BOOL;
    /////////////////////////
    
    setPos_Drad : MC_SetPosition;
    setPos_Dtank_Length : MC_SetPosition;
    setPos_Dtank_Pivot_To_Window : MC_SetPosition;
    dradDev : LREAL;
    dTankLengthDev : LREAL;
    dTankPivotWindowDev : LREAL;
    measurementAngleDev : LREAL;
    dOffAngledDev : LREAL;
    dOffParallelDev : LREAL;
    
    horizontalCalDev : LREAL;
    horizontalSampleDev : LREAL;
    verticalCalDev : LREAL;
    verticalSampleDev : LREAL;
    rotationCalDev : LREAL;
    rotationSampleDev : LREAL;
    measureOffsetDev : LREAL;
    
    bKinematicsOperational : BOOL;
    bVirtualsMoving : BOOL;
    writeDefault : FB_WritePersistentData;
    startupDelayTON : TON;
      
END_VAR

VAR CONSTANT
    DEVIATION_THRESHOLD : LREAL := 0.05;
END_VAR

VAR PERSISTENT
    Drad_default : LREAL := 3000;
    Dtank_Length_default : LREAL := 2289.15;
    Dtank_Pivot_To_Window_default : LREAL := 1648.66;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF GVL_INTER.ENABLE_ALL_AXES THEN
    EnableAxes();
END_IF

IF GVL_INTER.DISABLE_ALL_AXES THEN
    DisableAxes();
END_IF

//SAFETY RESET LOGIC (RESET AXES ON ESTOP RESET)
safetyFTrig(CLK:= GVL_Safety.SafetyReset);
IF safetyFTrig.Q THEN
    safetyResetLatch := TRUE;
    safetyResetDone:= FALSE;
    driveResetDone:= FALSE;
END_IF

safetyResetTON(IN:= safetyResetLatch, PT:=T#1S);
driveStartupDelay(IN:=safetyResetLatch,  PT:=T#2S);

IF safetyResetTON.Q THEN
    //safetyResetLatch:= FALSE;
    safetyResetDone := TRUE;
    GVL_INTER.RESET_ALL := TRUE;
END_IF

IF driveStartupDelay.Q THEN
    //safetyResetLatch:= FALSE;
    driveResetDone := TRUE;
END_IF

IF driveResetDone AND safetyResetDone THEN
    safetyResetLatch:= FALSE;
END_IF

IF GVL_INTER.RESET_ALL THEN
    ResetAll();
END_IF

//Check for errors at NC level
GVL_INTER.NC_AXIS_ERROR := CheckNcErrors();
VerticalAxesCalibrated := CheckVerticalCalibration();
VerticalAxesSpgEnabled := CheckZSpgStatus();
GVL_INTER.LIMIT_HIT:= CheckRealLimits();



(* Current thoughts,
Not sure I like the combined vertical axis, seems to add more hassle than it's worth as I have to set the position and such.
however, would be easier to link in a fail safe such that if mismatch between Z1 and Z2 position, then kill the enable/motion
Probably should progress with this route.
Also having to run the PLC to match NC cycle time otherwise position loop gets LOUD
Priority for next task:
Sort out the position mismatch fail safe AND monitor to ensure both axes are functional before allowing combined Z to move
MULTIPLE LAYERS OF FAILSAFE for synchronisation
Also setup the state logic for the setpoint generator of the Z
needs to handle the axes initially being in error before STO cleared, handle position setting,
Exiting this coupling for maintenance (tweaking of position)
And what happens when something falls over

*)



CombinedVerticalSetupComplete := FALSE;
IF GVL_INTER.RUN_COUPLED_VERTICAL AND driveResetDone THEN
    ////////////// RUN ALL THE TIME ///////////////////////////////////////        
    //Enable linking
    IF astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bEnabled AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bEnabled THEN
        //Only enable virtual axis if both RAW axes are homed/calibrated
        IF VerticalAxesCalibrated AND  VerticalAxesSpgEnabled AND NOT (astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bError OR astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bError)THEN
            astAxes[AXIS_COMBINED_VERTICAL].stControl.bEnable := TRUE;
        ELSE 
            astAxes[AXIS_COMBINED_VERTICAL].stControl.bEnable := FALSE;
		END_IF
	END_IF
    
    //Fwd limit linking
    astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitFwd := (astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitFwd AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitFwd);
    //Bwd limit linking
    astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitBwd := (astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitBwd AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd);
    
    //OVERRIDE LIMITS
    IF NOT decoupleVerticalMotion THEN
        astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitFwd := TRUE;
        astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitBwd := TRUE;
        astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitFwd := TRUE;
        astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd := TRUE;
	END_IF
    
    fVerticalSimulatedDeviation := astAxes[AXIS_COMBINED_VERTICAL].stStatus.fActPosition - astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.fActPosition;
    
    confirmSpgTimeout(PT:=T#1S);
    /////////////////////////////////////////////////////////////////////
    
    IF astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bError OR astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bError THEN
        eStateVertical:= eState_Vertical.init;
	END_IF
    
    actSyncVertStateMachine();
        
END_IF

combinedVerticalSetPos(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis);
combinedVerticalSetPos.Execute:= FALSE;

IF(astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.ActVelo>0) THEN
    combinedVerticalDirection := 1;
ELSIF (astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.ActVelo<0) THEN
    combinedVerticalDirection := -1;
ELSE 
    combinedVerticalDirection := 0;
END_IF

actZSetpoints();
verticalZ1SpgEnable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis);
verticalZ1SpgEnable.Execute:= FALSE;
verticalZ1SpgDisable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis);
verticalZ1SpgDisable.Execute:= FALSE;
verticalZ2SpgEnable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis);
verticalZ2SpgEnable.Execute:= FALSE;
verticalZ2SpgDisable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis);
verticalZ2SpgDisable.Execute:= FALSE;

writeDefault(NETID:='', PORT:=852);
writeDefault.START:= FALSE;

/////////////////////////////////ACTUAL LOGIC/////////////////////////////////////////
actCheckPositionDeviation();
actCheckRealSpgStatus();
startupDelayTON(PT:=T#200MS);
actKinematicSetpoints();
GVL_INTER.REAL_AXES_NOT_MOVING:= CheckRealNotMoving();
GVL_INTER.TARGET_MEASUREMENT_ANGLE:= astAxes[AXIS_MEASUREMENT_ANGLE].Axis.NcToPlc.SetPos + astAxes[AXIS_MEASUREMENT_ANGLE_OFFSET].Axis.NcToPlc.SetPos;
//DISABLE AXES (overridden if operational)
astAxes[AXIS_MEASUREMENT_ANGLE].stControl.bEnable := FALSE;




//RECOVERY MODE
IF GVL_INTER.START_RECOVERY AND GVL_INTER.RUN_KINEMATICS AND NOT GVL_INTER.RECOVERY_IN_PROGRESS THEN
    eStateInter:= eState_INTER.startRecovery;
END_IF

//REINITIALISE MODE
IF GVL_INTER.RUN_KINEMATICS AND GVL_INTER.REINITIALISE THEN
    GVL_INTER.RESET_ALL:= TRUE;
    GVL_INTER.REINITIALISE := FALSE;
    GVL_INTER.REINITIALISE_IN_PROGRESS:= TRUE;
    GVL_INTER.RUN_KINEMATICS := FALSE;
END_IF
IF GVL_INTER.FINISH_REINITIALISE AND GVL_INTER.REINITIALISE_IN_PROGRESS THEN
    GVL_INTER.FINISH_REINITIALISE:= FALSE;
    GVL_INTER.RUN_KINEMATICS:= TRUE;
    GVL_INTER.REINITIALISE_IN_PROGRESS:= FALSE;
END_IF

IF NOT GVL_INTER.KINEMATIC_SPG_ALL_DISABLED AND NOT GVL_INTER.RUN_KINEMATICS THEN
    eStateInter:= eState_INTER.disableSPG;
END_IF



IF CombinedVerticalSetupComplete THEN
    
    CASE eStateInter OF
        eState_INTER.init:
        //maybe some other stuff - make sure SPGs are not running (do a "gear" out)
            IF GVL_INTER.RUN_KINEMATICS THEN
                IF NOT GVL_INTER.KINEMATIC_SPG_ALL_DISABLED THEN
                    eStateInter:=eState_INTER.disableSPG;
                ELSE
                    eStateInter:= eState_INTER.setPositions;
			    END_IF
			END_IF
            
                        
        eState_INTER.setPositions:
            setPos_Drad.Position := Drad_default;
            setPos_Dtank_Length.Position := Dtank_Length_default;
            setPos_Dtank_Pivot_To_Window.Position := Dtank_Pivot_To_Window_default;
            setPos_Drad.Execute:= TRUE;
            setPos_Dtank_Length.Execute:= TRUE;
            setPos_Dtank_Pivot_To_Window.Execute:= TRUE;
            writeDefault.START:=TRUE;
            eStateInter := eState_INTER.checkSetPositions;
        
        eState_INTER.checkSetPositions:
            IF checkFirstCycle THEN
                IF bDefaultDevValid THEN
                    IF bRealDevValid THEN
                        eStateInter:= eState_INTER.enableSPG;
                        checkFirstCycle:=FALSE;
                    ELSE
                        eStateInter:= eState_INTER.alignKinematics;
                        checkFirstCycle:=FALSE;
			        END_IF
			    END_IF
            ELSE
                checkFirstCycle:= TRUE;
			END_IF
            //HANDLE IF WE GET STUCK IN THIS STATE
                                    
        eState_INTER.alignKinematics:
            //Send axes to default positions
            //Send real axes to where they would be if SPG'd
            //TO DO = SETUP DEFAULT VELOCITY SO DON'T NEED TO BE CALLED HERE
            startupDelayTON.IN:= TRUE;
            IF startupDelayTON.Q THEN
                startupDelayTON.IN:= FALSE;
                AbsoluteMove(axisID:= AXIS_HORIZONTAL_TRANSLATION, fPosition:= GVL_INTER.SETPOS_HORIZONTAL);
                AbsoluteMove(axisID:= AXIS_COMBINED_VERTICAL, fPosition:= GVL_INTER.SETPOS_COMBINED_VERTICAL);
                AbsoluteMove(axisID:= AXIS_ROTATION, fPosition:= GVL_INTER.SETPOS_ROTATION);
                eStateInter:= eState_INTER.checkAlignKinematics;
			END_IF
            
            
        eState_INTER.checkAlignKinematics:
            IF checkFirstCycle THEN
                //Move check and position check
                IF GVL_INTER.REAL_AXES_NOT_MOVING THEN
                    IF bRealDevValid THEN
                        //WE ARE IN CORRECT POSITION
                        checkFirstCycle := FALSE;
                        eStateInter:= eState_INTER.enableSPG;
					END_IF                    
				END_IF
                
            ELSE
                checkFirstCycle:= TRUE;
			END_IF
            
        eState_INTER.enableSPG:
            fbSPG_Y_Enable.Execute:= TRUE;
            fbSPG_Z_Enable.Execute:= TRUE;
            fbSPG_Rot_Enable.Execute:= TRUE;
            eStateInter:= eState_INTER.checkEnableSPG;
           
        eState_INTER.checkEnableSPG:
            IF GVL_INTER.KINEMATIC_SPG_ALL_ENABLED THEN
                eStateInter :=eState_INTER.operation;
			END_IF
        
        eState_INTER.operation:
            bKinematicsOperational:= TRUE;
            //IN HERE WE WILL CHECK SPGs STAY ENABLED AND ENABLE THE VIRTUAL AXES - to be completed
            IF NOT GVL_INTER.KINEMATIC_SPG_ALL_ENABLED THEN
                eStateInter:= eState_INTER.error;
			END_IF
            IF NOT GVL_INTER.NC_AXIS_ERROR THEN
                astAxes[AXIS_MEASUREMENT_ANGLE].stControl.bEnable := TRUE;
            END_IF
            
        eState_INTER.disableSPG:
            fbSPG_Y_Disable.Execute:= TRUE;
            fbSPG_Z_Disable.Execute:= TRUE;
            fbSPG_Rot_Disable.Execute:= TRUE;
            eStateInter:= eState_INTER.checkDisableSPG;
            
        eState_INTER.checkDisableSPG:
            IF NOT GVL_INTER.KINEMATIC_SPG_ALL_DISABLED THEN
                IF GVL_INTER.RECOVERY_IN_PROGRESS THEN
                    eStateInter:= eState_INTER.recoveryDefaultPosition;
                ELSE
                    eStateInter:= eState_INTER.init;
				END_IF
                
			END_IF
            
        eState_INTER.startRecovery:
            GVL_INTER.RECOVERY_IN_PROGRESS := TRUE;
            eStateInter:= eState_INTER.disableSPG;
        
        eState_INTER.recoveryDefaultPosition:
            IF GVL_INTER.NC_AXIS_ERROR THEN
                GVL_INTER.RESET_ALL := TRUE;
            ELSE
                AbsoluteMove(axisID:=AXIS_MEASUREMENT_ANGLE, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_MEASUREMENT_ANGLE_OFFSET, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_DOFF_ANGLED, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_DOFF_PARALLEL, fPosition:=0);
                
                AbsoluteMove(axisID:=AXIS_HORIZONTAL_CALIBRATION, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_HORIZONTAL_SAMPLE, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_COMBINED_VERTICAL_CALIBRATION, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_COMBINED_VERTICAL_SAMPLE, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_ROTATION_CALIBRATION, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_ROTATION_SAMPLE, fPosition:=0);
                
                AbsoluteMove(axisID:=AXIS_DRAD, fPosition:= Drad_default);
                AbsoluteMove(axisID:=AXIS_DTANK_LENGTH, fPosition:= Dtank_Length_default);
                AbsoluteMove(axisID:=AXIS_DTANK_PIVOT_TO_WINDOW, fPosition:= Dtank_Pivot_To_Window_default);
                eStateInter:= eState_INTER.waitForRecovery;
			END_IF
            
          
        eState_INTER.waitForRecovery:
            IF bRecoveryDevValid AND NOT bVirtualsMoving THEN
                GVL_INTER.START_RECOVERY:= FALSE;
                GVL_INTER.RECOVERY_IN_PROGRESS:= FALSE;
                eStateInter:= eState_INTER.init;
			END_IF
            
        eState_INTER.error:
            IF NOT GVL_INTER.NC_AXIS_ERROR THEN
                eStateInter:= eState_INTER.init;
			END_IF
            
	END_CASE
    
    //Override the enable on virtual axes (to do: add all the axes)
    IF GVL_INTER.RECOVERY_IN_PROGRESS OR GVL_INTER.REINITIALISE_IN_PROGRESS THEN
        astAxes[AXIS_MEASUREMENT_ANGLE].stControl.bEnable := TRUE;
        
	END_IF
    
    
END_IF

setPos_Drad(Axis:= astAxes[AXIS_DRAD].Axis);
setPos_Dtank_Length(Axis:=astAxes[AXIS_DTANK_LENGTH].Axis);
setPos_Dtank_Pivot_To_Window(Axis:=astAxes[AXIS_DTANK_PIVOT_TO_WINDOW].Axis);
setPos_Drad.Execute:= FALSE;
setPos_Dtank_Length.Execute:= FALSE;
setPos_Dtank_Pivot_To_Window.Execute:= FALSE;



//////

//SPG CALLS
MC_ExtSetPointGenFeed(Axis:= astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis, 
        Position:= GVL_INTER.SETPOS_HORIZONTAL,
        Velocity:=GVL_INTER.SETVELO_HORIZONTAL,
        Direction:= GVL_INTER.SETDIR_HORIZONTAL, Acceleration:= 0);
        
MC_ExtSetPointGenFeed(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis, 
        Position:= GVL_INTER.SETPOS_COMBINED_VERTICAL,
        Velocity:=GVL_INTER.SETVELO_COMBINED_VERTICAL,
        Direction:= GVL_INTER.SETDIR_COMBINED_VERTICAL, Acceleration:= 0);

MC_ExtSetPointGenFeed(Axis:= astAxes[AXIS_ROTATION].Axis, 
        Position:= GVL_INTER.SETPOS_ROTATION,
        Velocity:=GVL_INTER.SETVELO_ROTATION,
        Direction:= GVL_INTER.SETDIR_ROTATION, Acceleration:= 0);

fbSPG_Y_Enable(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis);
fbSPG_Y_Disable(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis);
fbSPG_Z_Enable(Axis:=astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis);
fbSPG_Z_Disable(Axis:=astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis);
fbSPG_Rot_Enable(Axis:=astAxes[AXIS_ROTATION].Axis);
fbSPG_Rot_Disable(Axis:=astAxes[AXIS_ROTATION].Axis);

fbSPG_Y_Enable.Execute:= FALSE;
fbSPG_Y_Disable.Execute:= FALSE;
fbSPG_Z_Enable.Execute:= FALSE;
fbSPG_Z_Disable.Execute:= FALSE;
fbSPG_Rot_Enable.Execute:= FALSE;
fbSPG_Rot_Disable.Execute:= FALSE;]]></ST>
    </Implementation>
    <Method Name="AbsoluteMove" Id="{6081ed68-b6ed-437f-92c9-8a8848dd8e14}">
      <Declaration><![CDATA[METHOD AbsoluteMove : BOOL
VAR_INPUT
    axisID : UINT;
    fPosition : LREAL;
    
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[astAxes[axisID].stControl.eCommand:= E_MotionFunctions.eMoveAbsolute;
astAxes[axisID].stControl.fPosition:= fPosition;
astAxes[axisID].stControl.bExecute:= TRUE;]]></ST>
      </Implementation>
    </Method>
    <Action Name="actCheckPositionDeviation" Id="{48a3beaa-86d1-4929-b3bc-c17d3fe46a74}">
      <Implementation>
        <ST><![CDATA[posDevZ:=    astAxes[AXIS_HORIZONTAL_TRANSLATION].stStatus.fActPosition - (astAxes[AXIS_HORIZONTAL_VIRTUAL].stStatus.fActPosition + astAxes[AXIS_HORIZONTAL_SAMPLE].stStatus.fActPosition + astAxes[AXIS_HORIZONTAL_CALIBRATION].stStatus.fActPosition);
posDevY:=    astAxes[AXIS_COMBINED_VERTICAL].stStatus.fActPosition - (astAxes[AXIS_COMBINED_VERTICAL_VIRTUAL].stStatus.fActPosition + astAxes[AXIS_COMBINED_VERTICAL_SAMPLE].stStatus.fActPosition + astAxes[AXIS_COMBINED_VERTICAL_CALIBRATION].stStatus.fActPosition);
posDevRot:=    astAxes[AXIS_ROTATION].stStatus.fActPosition - (astAxes[AXIS_ROTATION_VIRTUAL].stStatus.fActPosition + astAxes[AXIS_ROTATION_SAMPLE].stStatus.fActPosition + astAxes[AXIS_ROTATION_CALIBRATION].stStatus.fActPosition);

bRealDevValid := ABS(posDevZ)<DEVIATION_THRESHOLD AND ABS(posDevY)<DEVIATION_THRESHOLD AND ABS(posDevRot)<DEVIATION_THRESHOLD;

//Virtual calibration deviations
dradDev := astAxes[AXIS_DRAD].stStatus.fActPosition - Drad_default;
dTankLengthDev := astAxes[AXIS_DTANK_LENGTH].stStatus.fActPosition - Dtank_Length_default;
dTankPivotWindowDev := astAxes[AXIS_DTANK_PIVOT_TO_WINDOW].stStatus.fActPosition - Dtank_Pivot_To_Window_default;

bDefaultDevValid:= ABS(dradDev)<DEVIATION_THRESHOLD AND ABS(dTankLengthDev)<DEVIATION_THRESHOLD AND ABS(dTankPivotWindowDev)<DEVIATION_THRESHOLD;



//OTHER VIRTUAL AXES
measurementAngleDev := astAxes[AXIS_MEASUREMENT_ANGLE].stStatus.fActPosition;
dOffAngledDev := astAxes[AXIS_DOFF_ANGLED].stStatus.fActPosition;
dOffParallelDev := astAxes[AXIS_DOFF_PARALLEL].stStatus.fActPosition;

//CALIBRATION AND SAMPLE AXES - go to zero for recovery so just equal to position
horizontalCalDev := astAxes[AXIS_HORIZONTAL_CALIBRATION].stStatus.fActPosition;
horizontalSampleDev := astAxes[AXIS_HORIZONTAL_SAMPLE].stStatus.fActPosition;
verticalCalDev := astAxes[AXIS_COMBINED_VERTICAL_CALIBRATION].stStatus.fActPosition;
verticalSampleDev := astAxes[AXIS_COMBINED_VERTICAL_SAMPLE].stStatus.fActPosition;
rotationCalDev := astAxes[AXIS_ROTATION_CALIBRATION].stStatus.fActPosition;
rotationSampleDev := astAxes[AXIS_ROTATION_SAMPLE].stStatus.fActPosition;
measureOffsetDev := astAxes[AXIS_MEASUREMENT_ANGLE_OFFSET].stStatus.fActPosition;


bRecoveryDevValid:= bDefaultDevValid AND 
    ABS(measurementAngleDev)<DEVIATION_THRESHOLD AND 
    ABS(dOffAngledDev)<DEVIATION_THRESHOLD AND 
    ABS(dOffParallelDev)<DEVIATION_THRESHOLD AND
    ABS(horizontalCalDev)<DEVIATION_THRESHOLD AND
    ABS(horizontalSampleDev)<DEVIATION_THRESHOLD AND
    ABS(verticalCalDev)<DEVIATION_THRESHOLD AND
    ABS(verticalSampleDev)<DEVIATION_THRESHOLD AND
    ABS(rotationCalDev)<DEVIATION_THRESHOLD AND
    ABS(rotationSampleDev)<DEVIATION_THRESHOLD AND
    ABS(measureOffsetDev)<DEVIATION_THRESHOLD;

bVirtualsMoving:= astAxes[AXIS_DRAD].Axis.Status.Moving OR 
    astAxes[AXIS_DTANK_LENGTH].Axis.Status.Moving OR
    astAxes[AXIS_DTANK_PIVOT_TO_WINDOW].Axis.Status.Moving OR
    astAxes[AXIS_MEASUREMENT_ANGLE].Axis.Status.Moving OR
    astAxes[AXIS_DOFF_ANGLED].Axis.Status.Moving OR
    astAxes[AXIS_DOFF_PARALLEL].Axis.Status.Moving OR
    
    astAxes[AXIS_HORIZONTAL_CALIBRATION].Axis.Status.Moving OR
    astAxes[AXIS_HORIZONTAL_SAMPLE].Axis.Status.Moving OR
    astAxes[AXIS_COMBINED_VERTICAL_CALIBRATION].Axis.Status.Moving OR
    astAxes[AXIS_COMBINED_VERTICAL_SAMPLE].Axis.Status.Moving OR
    astAxes[AXIS_ROTATION_CALIBRATION].Axis.Status.Moving OR
    astAxes[AXIS_ROTATION_SAMPLE].Axis.Status.Moving OR
    astAxes[AXIS_MEASUREMENT_ANGLE_OFFSET].Axis.Status.Moving;]]></ST>
      </Implementation>
    </Action>
    <Action Name="actCheckRealSpgStatus" Id="{aa3cfb1c-6529-4170-bdb7-491608be6428}">
      <Implementation>
        <ST><![CDATA[GVL_INTER.KINEMATIC_SPG_ALL_ENABLED:= astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis.Status.ExtSetPointGenEnabled AND astAxes[AXIS_COMBINED_VERTICAL].Axis.Status.ExtSetPointGenEnabled AND astAxes[AXIS_ROTATION].Axis.Status.ExtSetPointGenEnabled;
GVL_INTER.KINEMATIC_SPG_ALL_DISABLED:= NOT (astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis.Status.ExtSetPointGenEnabled) AND NOT (astAxes[AXIS_COMBINED_VERTICAL].Axis.Status.ExtSetPointGenEnabled) AND NOT (astAxes[AXIS_ROTATION].Axis.Status.ExtSetPointGenEnabled);
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actKinematicSetpoints" Id="{f7732646-7f90-42f9-b38f-67cffb5e750d}">
      <Implementation>
        <ST><![CDATA[GVL_INTER.SETPOS_HORIZONTAL:= astAxes[AXIS_HORIZONTAL_VIRTUAL].Axis.NcToPlc.ActPos + astAxes[AXIS_HORIZONTAL_CALIBRATION].Axis.NcToPlc.ActPos + astAxes[AXIS_HORIZONTAL_SAMPLE].Axis.NcToPlc.ActPos;
GVL_INTER.SETVELO_HORIZONTAL:=astAxes[AXIS_HORIZONTAL_VIRTUAL].Axis.NcToPlc.ActVelo + astAxes[AXIS_HORIZONTAL_CALIBRATION].Axis.NcToPlc.ActVelo + astAxes[AXIS_HORIZONTAL_SAMPLE].Axis.NcToPlc.ActVelo;
GVL_INTER.SETPOS_COMBINED_VERTICAL:= astAxes[AXIS_COMBINED_VERTICAL_VIRTUAL].Axis.NcToPlc.ActPos + astAxes[AXIS_COMBINED_VERTICAL_CALIBRATION].Axis.NcToPlc.ActPos + astAxes[AXIS_COMBINED_VERTICAL_SAMPLE].Axis.NcToPlc.ActPos;
GVL_INTER.SETVELO_COMBINED_VERTICAL:= astAxes[AXIS_COMBINED_VERTICAL_VIRTUAL].Axis.NcToPlc.ActVelo + astAxes[AXIS_COMBINED_VERTICAL_CALIBRATION].Axis.NcToPlc.ActVelo + astAxes[AXIS_COMBINED_VERTICAL_SAMPLE].Axis.NcToPlc.ActVelo;
GVL_INTER.SETPOS_ROTATION:= astAxes[AXIS_ROTATION_VIRTUAL].Axis.NcToPlc.ActPos + astAxes[AXIS_ROTATION_CALIBRATION].Axis.NcToPlc.ActPos + astAxes[AXIS_ROTATION_SAMPLE].Axis.NcToPlc.ActPos;
GVL_INTER.SETVELO_ROTATION:= astAxes[AXIS_ROTATION_VIRTUAL].Axis.NcToPlc.ActVelo + astAxes[AXIS_ROTATION_CALIBRATION].Axis.NcToPlc.ActVelo + astAxes[AXIS_ROTATION_SAMPLE].Axis.NcToPlc.ActVelo;

//Horizontal direction
IF GVL_INTER.SETVELO_HORIZONTAL >0 THEN
    GVL_INTER.SETDIR_HORIZONTAL := 1;
ELSIF GVL_INTER.SETVELO_HORIZONTAL<0 THEN
    GVL_INTER.SETDIR_HORIZONTAL := -1;
ELSE
    GVL_INTER.SETDIR_HORIZONTAL := 0;
END_IF

//Vertical Direction
IF GVL_INTER.SETVELO_COMBINED_VERTICAL>0 THEN
    GVL_INTER.SETDIR_COMBINED_VERTICAL := 1;
ELSIF GVL_INTER.SETVELO_COMBINED_VERTICAL<0 THEN
    GVL_INTER.SETDIR_COMBINED_VERTICAL := -1;
ELSE
    GVL_INTER.SETDIR_COMBINED_VERTICAL := 0;
END_IF

//Rotation direction
IF GVL_INTER.SETVELO_ROTATION>0 THEN
    GVL_INTER.SETDIR_ROTATION := 1;
ELSIF GVL_INTER.SETVELO_ROTATION<0 THEN
    GVL_INTER.SETDIR_ROTATION := -1;
ELSE
    GVL_INTER.SETDIR_ROTATION := 0;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="actSyncVertStateMachine" Id="{86ee614e-4a39-40bc-bbfb-49053b8e3adf}">
      <Implementation>
        <ST><![CDATA[CASE eStateVertical OF
        eState_Vertical.init:
            IF NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bError AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bError THEN
                IF NOT decoupleVerticalMotion THEN
                    eStateVertical := eState_Vertical.checkPosition;
                END_IF
			END_IF
            
        eState_Vertical.checkPosition:
            //Assume Z1 and Z2 calibrated to be at same position
            IF ABS(fVerticalSimulatedDeviation)> fVerticalSimulatedDeviationAllowed THEN
                eStateVertical := eState_Vertical.setPosition; //should be setPosition state
            ELSE
                eStateVertical := eState_Vertical.enableSpg;
			END_IF
            
        eState_Vertical.setPosition:
            combinedVerticalSetPos.Position:= astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.fActPosition;
            combinedVerticalSetPos.Execute:= TRUE;
            eStateVertical := eState_Vertical.checkPosition;
            
        eState_Vertical.enableSpg:
            IF astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitBwd AND astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitFwd THEN
                verticalZ1SpgEnable.Execute := TRUE;
                verticalZ2SpgEnable.Execute := TRUE;
                eStateVertical := eState_Vertical.confirmEnableSpg;
            ELSE
                tempZ1Power(Axis:= astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis, Enable:= TRUE, Enable_Negative:=TRUE, Enable_Positive:=TRUE);
			    tempZ2Power(Axis:= astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis, Enable:= TRUE, Enable_Negative:=TRUE, Enable_Positive:=TRUE);
                verticalZ1SpgEnable.Execute := TRUE;
                verticalZ2SpgEnable.Execute := TRUE;
                eStateVertical := eState_Vertical.confirmEnableSpg;
            END_IF
            
        
        eState_Vertical.confirmEnableSpg:
            confirmSpgTimeout.IN:= TRUE;
            //Timeout check
            IF confirmSpgTimeout.Q THEN
                confirmSpgTimeout.IN:= FALSE;
                eStateVertical := eState_Vertical.init;
			END_IF
            IF VerticalAxesSpgEnabled THEN
                eStateVertical := eState_Vertical.operation;
			END_IF
        
        eState_Vertical.operation:
            //DO NOTHING
            CombinedVerticalSetupComplete := TRUE;
            IF NOT VerticalAxesSpgEnabled THEN
                eStateVertical:= eState_Vertical.init;
			END_IF
            IF decoupleVerticalMotion THEN
                eStateVertical := eState_Vertical.disableSpg;
			END_IF
            
        eState_Vertical.disableSpg:
            verticalZ1SpgDisable.Execute:= TRUE;
            verticalZ2SpgDisable.Execute:= TRUE;
            eStateVertical := eState_Vertical.confirmDisableSpg;
            
        eState_Vertical.confirmDisableSpg:
            IF NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.Status.ExtSetPointGenEnabled AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.Status.ExtSetPointGenEnabled THEN
                eStateVertical := eState_Vertical.init;
            ELSE
                eStateVertical := eState_Vertical.disableSpg;
			END_IF
            
	END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="actZSetpoints" Id="{facf07a9-589c-4d38-a5b7-e5a598ba95ba}">
      <Implementation>
        <ST><![CDATA[astAxes[AXIS_COMBINED_VERTICAL].Axis.ReadStatus();
astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.ReadStatus();
astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.ReadStatus();


//If still getting issues after setting up position and velocity control loops correctly
//expose feedback 1 velocity using PDO assignment at drive and then do comparator against this value
//before sending setpoint generator positions

Y1rTrig(CLK:= astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd);

IF(Y1rTrig.Q) THEN
    scalingActive := TRUE;
END_IF
IF scalingActive THEN
    cycleCounter:= cycleCounter+1;
END_IF
IF cycleCounter>500 THEN
    scalingActive := FALSE;
    cycleCounter:=0;
END_IF
//astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd:= TRUE;

//Z1 position check
IF ((astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos < astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos+0.01)OR (astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo<0)) 
    
    AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd THEN
    //ADSLOGSTR(msgCtrlMask:= ADSLOG_MSGTYPE_HINT,msgFmtStr:='HIT',strArg:='');
    fZ1SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ1SetVelo :=0;
    fZ1SetDir := 0;
ELSIF astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos > astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitFwd THEN
    fZ1SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ1SetVelo :=0;
    fZ1SetDir := 0;
ELSE
    IF scalingActive THEN
        fZ1SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
        fZ1SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo * (0.002*cycleCounter);
        fZ1SetDir := combinedVerticalDirection;
    ELSE
        fZ1SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
        fZ1SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo;
        fZ1SetDir := combinedVerticalDirection;
	END_IF
    //fZ1SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
    //fZ1SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo;
    //fZ1SetDir := combinedVerticalDirection;
END_IF

//Z2 position check
IF astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos < astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitBwd THEN
    fZ2SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ2SetVelo :=0;
    fZ2SetDir := 0;
ELSIF astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos > astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitFwd THEN
    fZ2SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ2SetVelo :=0;
    fZ2SetDir := 0;
ELSE
    fZ2SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
    fZ2SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo;
    fZ2SetDir := combinedVerticalDirection;
END_IF

MC_ExtSetPointGenFeed(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis, Position:= fZ1SetPos, Velocity:= fZ1SetVelo, Acceleration:= 0, Direction:= fZ1SetDir);
MC_ExtSetPointGenFeed(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis, Position:= fZ2SetPos, Velocity:= fZ2SetVelo, Acceleration:= 0, Direction:= fZ2SetDir);
]]></ST>
      </Implementation>
    </Action>
    <Method Name="CheckNcErrors" Id="{7139bf26-abbf-4cba-b321-d9387e4f0885}">
      <Declaration><![CDATA[METHOD CheckNcErrors : BOOL
VAR_INPUT
END_VAR
VAR
    i : UINT := 5;
    Error : BOOL := FALSE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i :=5 TO GVL_APP.nAXIS_NUM DO
    IF astAxes[i].stStatus.bError THEN
        Error := TRUE;
	END_IF
END_FOR
CheckNcErrors := Error;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckRealLimits" Id="{01c59cda-6c3f-45b5-9bb3-083eba480fd4}">
      <Declaration><![CDATA[METHOD CheckRealLimits : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//TRUE ON LIMIT HIT
CheckRealLimits:= NOT(astAxes[AXIS_ROTATION].stInputs.bLimitBwd) OR NOT(astAxes[AXIS_ROTATION].stInputs.bLimitFwd) OR
    NOT(astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitBwd) OR NOT(astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitFwd) OR
    NOT(astAxes[AXIS_HORIZONTAL_TRANSLATION].stInputs.bLimitBwd) OR NOT(astAxes[AXIS_HORIZONTAL_TRANSLATION].stInputs.bLimitFwd);]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckRealNotMoving" Id="{4b26f9f2-7656-4752-bd30-6a3f24f477be}">
      <Declaration><![CDATA[METHOD CheckRealNotMoving : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CheckRealNotMoving:= astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis.Status.NotMoving AND astAxes[AXIS_COMBINED_VERTICAL].Axis.Status.NotMoving AND astAxes[AXIS_ROTATION].Axis.Status.NotMoving;]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckVerticalCalibration" Id="{e1036243-04e4-4263-b466-d17b80a88071}">
      <Declaration><![CDATA[METHOD CheckVerticalCalibration : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CheckVerticalCalibration := astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.Status.Homed AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.Status.Homed;]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckZSpgStatus" Id="{be3f907d-6383-4f00-95cd-2d71447606c2}">
      <Declaration><![CDATA[METHOD CheckZSpgStatus : BOOL
VAR
    SpgSet : BOOL := FALSE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SpgSet := astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.Status.ExtSetPointGenEnabled AND astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.Status.ExtSetPointGenEnabled;
CheckZSpgStatus := SpgSet;]]></ST>
      </Implementation>
    </Method>
    <Method Name="DisableAxes" Id="{445cd5b3-7fd2-4adb-8098-44aeb3439028}">
      <Declaration><![CDATA[METHOD DisableAxes : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[astAxes[AXIS_HORIZONTAL_TRANSLATION].stControl.bEnable :=FALSE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stControl.bEnable :=FALSE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stControl.bEnable :=FALSE;
astAxes[AXIS_ROTATION].stControl.bEnable :=FALSE;
GVL_INTER.DISABLE_ALL_AXES := FALSE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="EnableAxes" Id="{b0c85ed2-0ac0-448f-af10-0513bd266d32}">
      <Declaration><![CDATA[METHOD EnableAxes : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[astAxes[AXIS_HORIZONTAL_TRANSLATION].stControl.bEnable :=TRUE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stControl.bEnable :=TRUE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stControl.bEnable :=TRUE;
astAxes[AXIS_ROTATION].stControl.bEnable :=TRUE;
GVL_INTER.ENABLE_ALL_AXES := FALSE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetAll" Id="{e4647f95-e102-4ec6-b060-9c49e98b19a4}">
      <Declaration><![CDATA[METHOD ResetAll : BOOL
VAR_INPUT
END_VAR

VAR
    i : UINT :=5;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i :=5 TO GVL_APP.nAXIS_NUM DO
        astAxes[i].stControl.bReset:= TRUE;
END_FOR

GVL_INTER.RESET_ALL := FALSE;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>