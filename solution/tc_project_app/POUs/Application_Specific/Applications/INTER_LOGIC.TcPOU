<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="INTER_LOGIC" Id="{da89d596-93f4-468f-9a43-1a72f2055b25}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM INTER_LOGIC
VAR
    IDs_RealAxes : ARRAY[1..ARRAYSIZE_REAL] OF UINT:= 
        [AXIS_HORIZONTAL_TRANSLATION,AXIS_COMBINED_VERTICAL,AXIS_ROTATION];
    
    IDs_VirtualWithCalibrationAxes : ARRAY[1..ARRAYSIZE_VIRTUALCAL] OF UINT:=
        [AXIS_DRAD,AXIS_DTANK_LENGTH,AXIS_DTANK_PIVOT_TO_WINDOW];
    IDs_VirtualNoCalibrationAxes : ARRAY[1..ARRAYSIZE_VIRTUAL] OF UINT:=
        [AXIS_MEASUREMENT_ANGLE,
        AXIS_DOFF_ANGLED,
        AXIS_DOFF_PARALLEL,
        AXIS_HORIZONTAL_CALIBRATION,
        AXIS_HORIZONTAL_SAMPLE,
        AXIS_COMBINED_VERTICAL_CALIBRATION,
        AXIS_COMBINED_VERTICAL_SAMPLE,
        AXIS_ROTATION_CALIBRATION,
        AXIS_ROTATION_SAMPLE,
        AXIS_MEASUREMENT_ANGLE_OFFSET];    
    
    calibrationValuesArray : ARRAY[1..ARRAYSIZE_VIRTUALCAL] OF LREAL;
    
    
    
    arraysSetup : BOOL := FALSE;
    driveStartupDelay : TON;

    
    safetyFTrig : F_TRIG;
    safetyResetTON : TON;
    safetyResetLatch : BOOL :=FALSE;
    safetyResetDone: BOOL;
    driveResetDone : BOOL;
    bRotationValid : BOOL:= FALSE;
    setPosRotation : MC_SetPosition;
    
    
    CombinedVerticalSetupComplete : BOOL := FALSE;
    AllowedVerticalLag : LREAL := 0.2;  //How much offset is allowed between two vertical axes when synced
    VerticalAxesCalibrated : BOOL := FALSE;
    VerticalAxesSpgEnabled : BOOL := FALSE;
    
    verticalZ1SpgEnable : MC_ExtSetPointGenEnable;
    verticalZ1SpgDisable : MC_ExtSetPointGenDisable;
    verticalZ2SpgEnable : MC_ExtSetPointGenEnable;
    verticalZ2SpgDisable : MC_ExtSetPointGenDisable;
    
    
    combinedVerticalSetPos : MC_SetPosition();
    
    eStateVertical : eState_Vertical := eState_Vertical.init;
    fVerticalSimulatedDeviation : LREAL;
    fVerticalSimulatedDeviationAllowed : LREAL := 0.1;
    confirmSpgTimeout : TON;
    
    tempZ1Power : MC_Power;
    tempZ2Power : MC_Power;
    
    fZ1SetPos : LREAL;
    fZ1SetVelo : LREAL;
    fZ2SetPos : LREAL;
    fZ2SetVelo : LREAL;
    fZ1SetDir : DINT;
    fZ2SetDir : DINT;
    combinedVerticalDirection : DINT;
    
    
    
//STUPID DEMO CODE
    Y1rTrig : R_TRIG;
    cycleCounter : LREAL:=0; 
    scalingActive : BOOL := FALSE;   
    
    
    //////////////////////////////////////////////////
    fbSPG_Y_Enable : MC_ExtSetPointGenEnable;
    fbSPG_Y_Disable : MC_ExtSetPointGenDisable;
    fbSPG_Z_Enable : MC_ExtSetPointGenEnable;
    fbSPG_Z_Disable : MC_ExtSetPointGenDisable;
    fbSPG_Rot_Enable : MC_ExtSetPointGenEnable;
    fbSPG_Rot_Disable : MC_ExtSetPointGenDisable;
    enableSPGs : BOOL;
    disableSPGs : BOOL;
        
    /////////////////////////
    eStateInter : eState_INTER := eState_INTER.init;
    checkFirstCycle : BOOL;
    posDevHorizontal : LREAL;
    posDevVertical : LREAL;
    posDevRot : LREAL;
    bRealDevValid : BOOL;
    bDefaultDevValid : BOOL;
    bRecoveryDevValid : BOOL;
    /////////////////////////
    
    setPos_Drad : MC_SetPosition;
    setPos_Dtank_Length : MC_SetPosition;
    setPos_Dtank_Pivot_To_Window : MC_SetPosition;
    
    bKinematicsOperational : BOOL;
    bVirtualsMoving : BOOL;
    writeDefault : FB_WritePersistentData;
    
    startupDelayTON : TON;
    timeoutDelay : TON;
    stateDelayTimer : TON;
    retryCounter : INT := 0;
    
    i : INT :=0; //iterator for FOR loops
      
END_VAR

VAR CONSTANT
    DEVIATION_THRESHOLD : LREAL := 0.05;
    ARRAYSIZE_REAL : INT := 3;
    ARRAYSIZE_VIRTUALCAL : INT :=3;
    ARRAYSIZE_VIRTUAL : INT:= 10;
    ARRAYSIZE_ALLVIRTUALS : INT:=13;
END_VAR

VAR PERSISTENT
    Drad_default : LREAL := 3000;
    Dtank_Length_default : LREAL := 2289.15;
    Dtank_Pivot_To_Window_default : LREAL := 1648.66;
    
    aVirtualAxisDefaults : ARRAY [1..ARRAYSIZE_ALLVIRTUALS] OF ST_DefaultVals:=
    [(axisID:=AXIS_DRAD, defaultPosition:=3000),
     (axisID:=AXIS_DTANK_LENGTH, defaultPosition:=2289.15),
    (axisID:=AXIS_DTANK_PIVOT_TO_WINDOW, defaultPosition:=1648.66),
    (axisID:=AXIS_MEASUREMENT_ANGLE, defaultPosition:=0),
    (axisID:=AXIS_DOFF_ANGLED, defaultPosition:=0),
    (axisID:=AXIS_DOFF_PARALLEL, defaultPosition:=0),
    (axisID:=AXIS_HORIZONTAL_CALIBRATION, defaultPosition:=0),
    (axisID:=AXIS_HORIZONTAL_SAMPLE, defaultPosition:=0),
    (axisID:=AXIS_COMBINED_VERTICAL_CALIBRATION, defaultPosition:=0),
    (axisID:=AXIS_COMBINED_VERTICAL_SAMPLE, defaultPosition:=0),
    (axisID:=AXIS_ROTATION_CALIBRATION, defaultPosition:=0),
    (axisID:=AXIS_ROTATION_SAMPLE, defaultPosition:=0),
    (axisID:=AXIS_MEASUREMENT_ANGLE_OFFSET, defaultPosition:=0)]

(*

    IDs_VirtualNoCalibrationAxes : ARRAY[1..ARRAYSIZE_VIRTUAL] OF UINT:=

        AXIS_COMBINED_VERTICAL_SAMPLE,
        AXIS_ROTATION_CALIBRATION,
        AXIS_ROTATION_SAMPLE,
        AXIS_MEASUREMENT_ANGLE_OFFSET];   *)

;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//SETUP ARRAYS - To be deleted
calibrationValuesArray[1]:= Drad_default;
calibrationValuesArray[2]:= Dtank_Length_default;
calibrationValuesArray[3]:= Dtank_Pivot_To_Window_default;

//aVirtualAxisDefaults[1].mcSetPosition(Axis:=astAxes[aVirtualAxisDefaults[1].axisID].Axis);
//aVirtualAxisDefaults[1].mcSetPosition.Execute:= TRUE;
//aVirtualAxisDefaults[1].mcSetPosition.Position:= aVirtualAxisDefaults[1].defaultPosition;


IF GVL_INTER.ENABLE_ALL_AXES THEN
    EnableAxes();
END_IF

IF GVL_INTER.DISABLE_ALL_AXES THEN
    DisableAxes();
END_IF

//SAFETY RESET LOGIC (RESET AXES ON ESTOP RESET)
safetyFTrig(CLK:= GVL_Safety.SafetyReset);
IF safetyFTrig.Q THEN
    safetyResetLatch := TRUE;
    safetyResetDone:= FALSE;
    driveResetDone:= FALSE;
END_IF

safetyResetTON(IN:= safetyResetLatch, PT:=T#1S);
driveStartupDelay(IN:=safetyResetLatch,  PT:=T#2S);

IF safetyResetTON.Q THEN
    //safetyResetLatch:= FALSE;
    safetyResetDone := TRUE;
    GVL_INTER.RESET_ALL := TRUE;
END_IF

IF driveStartupDelay.Q THEN
    //safetyResetLatch:= FALSE;
    driveResetDone := TRUE;
END_IF

IF driveResetDone AND safetyResetDone THEN
    safetyResetLatch:= FALSE;
END_IF

IF GVL_INTER.RESET_ALL THEN
    ResetAll();
END_IF

//Check for errors at NC level
GVL_INTER.NC_AXIS_ERROR := CheckNcErrors();
VerticalAxesCalibrated := CheckVerticalCalibration();
VerticalAxesSpgEnabled := CheckZSpgStatus();
GVL_INTER.LIMIT_HIT:= CheckRealLimits();




CombinedVerticalSetupComplete := FALSE;
IF GVL_INTER.RUN_COUPLED_VERTICAL AND driveResetDone THEN
    ////////////// RUN ALL THE TIME ///////////////////////////////////////        
    //Enable linking
    IF astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bEnabled AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bEnabled THEN
        //Only enable virtual axis if both RAW axes are homed/calibrated
        IF VerticalAxesCalibrated AND  VerticalAxesSpgEnabled AND NOT (astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bError OR astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bError)THEN
            astAxes[AXIS_COMBINED_VERTICAL].stControl.bEnable := TRUE;
        ELSE 
            astAxes[AXIS_COMBINED_VERTICAL].stControl.bEnable := FALSE;
		END_IF
	END_IF
    
    //Fwd limit linking
    astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitFwd := (astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitFwd AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitFwd);
    //Bwd limit linking
    astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitBwd := (astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitBwd AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd);
    
    //OVERRIDE LIMITS
    IF NOT GVL_INTER.DECOUPLE_VERTICAL_AXES THEN
        astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitFwd := TRUE;
        astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitBwd := TRUE;
        astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitFwd := TRUE;
        astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd := TRUE;
	END_IF
    
    fVerticalSimulatedDeviation := astAxes[AXIS_COMBINED_VERTICAL].stStatus.fActPosition - astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.fActPosition;
    
    confirmSpgTimeout(PT:=T#1S);
    /////////////////////////////////////////////////////////////////////
    
    IF astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bError OR astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bError THEN
        eStateVertical:= eState_Vertical.init;
	END_IF
    
    actSyncVertStateMachine();
        
END_IF

combinedVerticalSetPos(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis);
combinedVerticalSetPos.Execute:= FALSE;

IF(astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.ActVelo>0) THEN
    combinedVerticalDirection := 1;
ELSIF (astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.ActVelo<0) THEN
    combinedVerticalDirection := -1;
ELSE 
    combinedVerticalDirection := 0;
END_IF

actZSetpoints();
verticalZ1SpgEnable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis);
verticalZ1SpgEnable.Execute:= FALSE;
verticalZ1SpgDisable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis);
verticalZ1SpgDisable.Execute:= FALSE;
verticalZ2SpgEnable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis);
verticalZ2SpgEnable.Execute:= FALSE;
verticalZ2SpgDisable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis);
verticalZ2SpgDisable.Execute:= FALSE;

writeDefault(NETID:='', PORT:=852);
writeDefault.START:= FALSE;

(*
 __    __  ______  __    __  ________  __       __   ______   ________  ______   ______    ______  
/  |  /  |/      |/  \  /  |/        |/  \     /  | /      \ /        |/      | /      \  /      \ 
$$ | /$$/ $$$$$$/ $$  \ $$ |$$$$$$$$/ $$  \   /$$ |/$$$$$$  |$$$$$$$$/ $$$$$$/ /$$$$$$  |/$$$$$$  |
$$ |/$$/    $$ |  $$$  \$$ |$$ |__    $$$  \ /$$$ |$$ |__$$ |   $$ |     $$ |  $$ |  $$/ $$ \__$$/ 
$$  $$<     $$ |  $$$$  $$ |$$    |   $$$$  /$$$$ |$$    $$ |   $$ |     $$ |  $$ |      $$      \ 
$$$$$  \    $$ |  $$ $$ $$ |$$$$$/    $$ $$ $$/$$ |$$$$$$$$ |   $$ |     $$ |  $$ |   __  $$$$$$  |
$$ |$$  \  _$$ |_ $$ |$$$$ |$$ |_____ $$ |$$$/ $$ |$$ |  $$ |   $$ |    _$$ |_ $$ \__/  |/  \__$$ |
$$ | $$  |/ $$   |$$ | $$$ |$$       |$$ | $/  $$ |$$ |  $$ |   $$ |   / $$   |$$    $$/ $$    $$/ 
$$/   $$/ $$$$$$/ $$/   $$/ $$$$$$$$/ $$/      $$/ $$/   $$/    $$/    $$$$$$/  $$$$$$/   $$$$$$/  
                                                                                                   
*)


actCheckPositionDeviation();
actCheckRealSpgStatus();

startupDelayTON(PT:=T#200MS);
stateDelayTimer(PT:=T#200MS);
timeoutDelay(PT:=T#2S);

actKinematicSetpoints();
actCheckNotMoving();

GVL_INTER.TARGET_MEASUREMENT_ANGLE:= astAxes[AXIS_MEASUREMENT_ANGLE].Axis.NcToPlc.SetPos + astAxes[AXIS_MEASUREMENT_ANGLE_OFFSET].Axis.NcToPlc.SetPos;

//DISABLE AXES (overridden if operational)
//astAxes[AXIS_MEASUREMENT_ANGLE].stControl.bEnable := FALSE;

//execute all virtual mcsetpositions
FOR i:=1 TO ARRAYSIZE_ALLVIRTUALS DO
    aVirtualAxisDefaults[i].mcSetPosition(Axis:= astAxes[aVirtualAxisDefaults[i].axisID].Axis);
    aVirtualAxisDefaults[i].mcSetPosition.Execute:= FALSE;
END_FOR


//RECOVERY MODE
IF GVL_INTER.START_RECOVERY AND GVL_INTER.RUN_KINEMATICS AND NOT GVL_INTER.RECOVERY_IN_PROGRESS THEN
    eStateInter:= eState_INTER.startRecovery;
END_IF

//REINITIALISE MODE - DON'T ALLOW OTHER COMMANDS
IF GVL_INTER.REINITIALISE_IN_PROGRESS THEN
    GVL_INTER.REINITIALISE:= FALSE;
    GVL_INTER.START_RECOVERY:= FALSE;
END_IF
IF GVL_INTER.REINITIALISE_IN_PROGRESS AND eStateInter= eState_INTER.error THEN
    GVL_INTER.REINITIALISE_IN_PROGRESS:= FALSE;
END_IF

IF GVL_INTER.RUN_KINEMATICS AND GVL_INTER.REINITIALISE THEN
    GVL_INTER.RESET_ALL:= TRUE;
    GVL_INTER.REINITIALISE := FALSE;
    GVL_INTER.REINITIALISE_IN_PROGRESS:= TRUE;
    GVL_INTER.RUN_KINEMATICS := FALSE;
END_IF
IF GVL_INTER.FINISH_REINITIALISE AND NOT GVL_INTER.REINITIALISE_IN_PROGRESS THEN
    GVL_INTER.FINISH_REINITIALISE:= FALSE;
END_IF
IF GVL_INTER.FINISH_REINITIALISE AND GVL_INTER.REINITIALISE_IN_PROGRESS THEN
    GVL_INTER.FINISH_REINITIALISE:= FALSE;
    GVL_INTER.RUN_KINEMATICS:= TRUE;
    GVL_INTER.REINITIALISE_IN_PROGRESS:= FALSE;
END_IF

IF NOT GVL_INTER.KINEMATIC_SPG_ALL_DISABLED AND NOT GVL_INTER.RUN_KINEMATICS THEN
    eStateInter:= eState_INTER.disableSPG;
END_IF


GVL_INTER.OPERATIONAL:= FALSE;  //OVERRIDE IF OPERATIONAL
IF NOT CombinedVerticalSetupComplete AND GVL_INTER.OPERATIONAL THEN
    eStateInter:= eState_INTER.init;
END_IF

//Sometimes the rotation loads in 360degrees out of phase, we need to be able to detect and fix this.
setPosRotation(Axis:= astAxes[AXIS_ROTATION].Axis);
setPosRotation.Execute:= FALSE;
IF ABS(astAxes[AXIS_ROTATION].Axis.NcToPlc.ActPos)>20 THEN
    astAxes[AXIS_ROTATION].stControl.bEnable:= FALSE;
    IF astAxes[AXIS_ROTATION].Axis.NcToPlc.ActPos>20 THEN
        //we need to minus 360
        setPosRotation.Position:= astAxes[AXIS_ROTATION].Axis.NcToPlc.ActPos-360;
        setPosRotation.Execute:= TRUE;
    ELSIF astAxes[AXIS_ROTATION].Axis.NcToPlc.ActPos<20 THEN
        //we need to add 360
        setPosRotation.Position:= astAxes[AXIS_ROTATION].Axis.NcToPlc.ActPos+360;
        setPosRotation.Execute:= TRUE;
    END_IF
ELSE
    bRotationValid:= TRUE;
END_IF

    
    CASE eStateInter OF
        eState_INTER.init:       
            IF GVL_INTER.RUN_KINEMATICS AND CombinedVerticalSetupComplete AND bRotationValid THEN
                IF NOT GVL_INTER.KINEMATIC_SPG_ALL_DISABLED THEN
                    eStateInter:=eState_INTER.disableSPG;
                ELSE
                    eStateInter:= eState_INTER.setPositions;
			    END_IF
			END_IF
            
                        
        eState_INTER.setPositions:
            setPos_Drad.Position := Drad_default;
            setPos_Dtank_Length.Position := Dtank_Length_default;
            setPos_Dtank_Pivot_To_Window.Position := Dtank_Pivot_To_Window_default;
            setPos_Drad.Execute:= TRUE;
            setPos_Dtank_Length.Execute:= TRUE;
            setPos_Dtank_Pivot_To_Window.Execute:= TRUE;
            writeDefault.START:=TRUE;
            
            //FOR LOOP HERE TO ITERATE THROUGH VIRTUAL ARRAY MC_SETPOSITIONS
            stateDelayTimer.IN:= TRUE;
            IF(stateDelayTimer.Q) THEN
                eStateInter := eState_INTER.checkSetPositions;
                stateDelayTimer.IN:= FALSE;
			END_IF
            
        
        eState_INTER.checkSetPositions:
            //IF SET POSITION COMMANDS FAIL THEN bDefaultDevValid never reached
            IF bDefaultDevValid THEN
                retryCounter:= 0;
                IF bRealDevValid THEN
                    eStateInter:= eState_INTER.enableSPG;
                ELSE
                    eStateInter:= eState_INTER.alignKinematics;
			    END_IF
            ELSE
                IF retryCounter >3 THEN
                    retryCounter:= 0;
                    eStateInter:= eState_INTER.error;
                    GVL_INTER.LOGIC_ERROR:= TRUE;
                ELSE
                    retryCounter:= retryCounter+1;
                    eStateInter:= eState_INTER.setPositions;
				END_IF                
			END_IF               


        eState_INTER.alignKinematics:
            //Send real axes to where they would be if SPG'd
            //TO DO = SETUP DEFAULT VELOCITY SO DON'T NEED TO BE CALLED HERE
            startupDelayTON.IN:= TRUE;
            IF startupDelayTON.Q THEN
                startupDelayTON.IN:= FALSE;
                AbsoluteMove(axisID:= AXIS_HORIZONTAL_TRANSLATION, fPosition:= GVL_INTER.SETPOS_HORIZONTAL);
                AbsoluteMove(axisID:= AXIS_COMBINED_VERTICAL, fPosition:= GVL_INTER.SETPOS_COMBINED_VERTICAL);
                AbsoluteMove(axisID:= AXIS_ROTATION, fPosition:= GVL_INTER.SETPOS_ROTATION);               
                stateDelayTimer.IN:= TRUE;
			END_IF
            IF stateDelayTimer.Q THEN
                eStateInter:= eState_INTER.checkAlignKinematics;
                stateDelayTimer.IN:= FALSE;
			END_IF
            IF NOT (startupDelayTON.IN OR stateDelayTimer.IN) THEN
                //SOMETHING'S GONE WRONG
                GVL_INTER.LOGIC_ERROR:= TRUE;
                eStateInter:= eState_INTER.error;
			END_IF
            

        eState_INTER.checkAlignKinematics:
            //MONITOR FOR REAL AXES MOVE FINISHED (OR NEVER STARTED)
            IF GVL_INTER.REAL_AXES_NOT_MOVING THEN   
                timeoutDelay.IN:= TRUE;            
                //POSITION DEVIATIONS ARE VALID
                IF bRealDevValid THEN
                    timeoutDelay.IN:= FALSE;
                    eStateInter:= eState_INTER.enableSPG;
		        END_IF
                //LIMIT HIT (e.g. unlikely to get to right position based on current inputs)
                IF GVL_INTER.LIMIT_HIT THEN
                    timeoutDelay.IN:= FALSE;
                    GVL_INTER.LOGIC_ERROR:= TRUE;
                    eStateInter:= eState_INTER.error;
				END_IF
                //Timeout waiting for axes to position
                IF timeoutDelay.Q THEN
                    timeoutDelay.IN:= FALSE;
                    GVL_INTER.LOGIC_ERROR:= TRUE;
                    eStateInter:= eState_INTER.error;
				END_IF
		    END_IF
                
            
        eState_INTER.enableSPG:
            fbSPG_Y_Enable.Execute:= TRUE;
            fbSPG_Z_Enable.Execute:= TRUE;
            fbSPG_Rot_Enable.Execute:= TRUE;
            stateDelayTimer.IN:= TRUE;
            IF stateDelayTimer.Q THEN
                stateDelayTimer.IN:= FALSE;
                eStateInter:= eState_INTER.checkEnableSPG;
			END_IF
            
           
        eState_INTER.checkEnableSPG:
            IF GVL_INTER.KINEMATIC_SPG_ALL_ENABLED THEN
                retryCounter:= 0;
                eStateInter :=eState_INTER.operation;
            ELSE
                IF retryCounter >3 THEN
                    retryCounter:= 0;
                    eStateInter:= eState_INTER.error;
                    GVL_INTER.LOGIC_ERROR:= TRUE;
                ELSE
                    retryCounter:= retryCounter+1;
                    eStateInter:= eState_INTER.enableSPG;
		        END_IF 
			END_IF
            
        
        eState_INTER.operation:
            bKinematicsOperational:= TRUE;
            //IN HERE WE WILL CHECK SPGs STAY ENABLED AND ENABLE THE VIRTUAL AXES - to be completed
            IF NOT GVL_INTER.KINEMATIC_SPG_ALL_ENABLED THEN
                eStateInter:= eState_INTER.error;
			END_IF
            IF NOT GVL_INTER.NC_AXIS_ERROR THEN
                GVL_INTER.OPERATIONAL:= TRUE;
            END_IF
            
        eState_INTER.disableSPG:
            fbSPG_Y_Disable.Execute:= TRUE;
            fbSPG_Z_Disable.Execute:= TRUE;
            fbSPG_Rot_Disable.Execute:= TRUE;
            stateDelayTimer.IN:= TRUE;
            IF stateDelayTimer.Q THEN
                stateDelayTimer.IN:= FALSE;
                eStateInter:= eState_INTER.checkDisableSPG;
			END_IF
            
        eState_INTER.checkDisableSPG:
            IF GVL_INTER.KINEMATIC_SPG_ALL_DISABLED THEN
                retryCounter:= 0;
                IF GVL_INTER.RECOVERY_IN_PROGRESS THEN
                    eStateInter:= eState_INTER.recoveryDefaultPosition;
                ELSE
                    eStateInter:= eState_INTER.init;
				END_IF
            ELSE
                IF retryCounter >3 THEN
                    retryCounter:= 0;
                    eStateInter:= eState_INTER.error;
                    GVL_INTER.LOGIC_ERROR:= TRUE;
                ELSE
                    retryCounter:= retryCounter+1;
                    eStateInter:= eState_INTER.disableSPG;
		        END_IF 
			END_IF
            
        eState_INTER.startRecovery:
            GVL_INTER.RECOVERY_IN_PROGRESS := TRUE;
            eStateInter:= eState_INTER.disableSPG;
        
        eState_INTER.recoveryDefaultPosition:
            IF GVL_INTER.NC_AXIS_ERROR THEN
                GVL_INTER.RESET_ALL := TRUE;
            ELSE
                //THIS ALL CHANGES TO MC_SETPOSITION
                AbsoluteMove(axisID:=AXIS_MEASUREMENT_ANGLE, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_MEASUREMENT_ANGLE_OFFSET, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_DOFF_ANGLED, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_DOFF_PARALLEL, fPosition:=0);
                
                AbsoluteMove(axisID:=AXIS_HORIZONTAL_CALIBRATION, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_HORIZONTAL_SAMPLE, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_COMBINED_VERTICAL_CALIBRATION, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_COMBINED_VERTICAL_SAMPLE, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_ROTATION_CALIBRATION, fPosition:=0);
                AbsoluteMove(axisID:=AXIS_ROTATION_SAMPLE, fPosition:=0);
                
                AbsoluteMove(axisID:=AXIS_DRAD, fPosition:= Drad_default);
                AbsoluteMove(axisID:=AXIS_DTANK_LENGTH, fPosition:= Dtank_Length_default);
                AbsoluteMove(axisID:=AXIS_DTANK_PIVOT_TO_WINDOW, fPosition:= Dtank_Pivot_To_Window_default);
                
                stateDelayTimer.IN:= TRUE;
                IF stateDelayTimer.Q THEN
                    stateDelayTimer.IN:= FALSE;
                    eStateInter:= eState_INTER.waitForRecovery;
			    END_IF
			END_IF
            
          
        eState_INTER.waitForRecovery:
            IF GVL_INTER.VIRTUAL_AXES_NOT_MOVING THEN                
                timeoutDelay.IN:= TRUE;            
                //POSITION DEVIATIONS ARE VALID
                IF bRecoveryDevValid THEN
                    timeoutDelay.IN:= FALSE;
                    GVL_INTER.START_RECOVERY:= FALSE;
                    GVL_INTER.RECOVERY_IN_PROGRESS:= FALSE;
                    eStateInter:= eState_INTER.init;                                
			    END_IF
                
                //Timeout waiting for axes to position
                IF timeoutDelay.Q THEN
                    timeoutDelay.IN:= FALSE;
                    GVL_INTER.LOGIC_ERROR:= TRUE;
                    GVL_INTER.START_RECOVERY:= FALSE;
                    GVL_INTER.RECOVERY_IN_PROGRESS:= FALSE;
                    eStateInter:= eState_INTER.error;
				END_IF           
			END_IF
            
            
        eState_INTER.error:
            IF GVL_INTER.ACKNOWLEDGE_LOGIC_ERROR THEN
                GVL_INTER.LOGIC_ERROR:= FALSE;
                GVL_INTER.RESET_ALL:= TRUE;
			END_IF
            IF NOT GVL_INTER.NC_AXIS_ERROR  AND NOT GVL_INTER.LOGIC_ERROR THEN
                eStateInter:= eState_INTER.init;
                GVL_INTER.LOGIC_ERROR:= FALSE;  //MAKE ROBUST
			END_IF
            
	END_CASE
    
    //Override the enable AND LIMITS on virtual axes (to do: add all the axes)
    IF GVL_INTER.RECOVERY_IN_PROGRESS OR GVL_INTER.REINITIALISE_IN_PROGRESS OR GVL_INTER.OPERATIONAL THEN
        //astAxes[AXIS_MEASUREMENT_ANGLE].stControl.bEnable := TRUE;
        //TEST
        FOR i:=1 TO ARRAYSIZE_VIRTUALCAL DO
            astAxes[IDs_VirtualWithCalibrationAxes[i]].stControl.bEnable:=TRUE;
            astAxes[IDs_VirtualWithCalibrationAxes[i]].stInputs.bLimitBwd:=TRUE;
            astAxes[IDs_VirtualWithCalibrationAxes[i]].stInputs.bLimitFwd:=TRUE;
		END_FOR
        FOR i:=1 TO ARRAYSIZE_VIRTUAL DO
            astAxes[IDs_VirtualNoCalibrationAxes[i]].stControl.bEnable:=TRUE;
            astAxes[IDs_VirtualNoCalibrationAxes[i]].stInputs.bLimitBwd:=TRUE;
            astAxes[IDs_VirtualNoCalibrationAxes[i]].stInputs.bLimitFwd:=TRUE;
		END_FOR
    ELSE
        FOR i:=1 TO ARRAYSIZE_VIRTUALCAL DO
            astAxes[IDs_VirtualWithCalibrationAxes[i]].stControl.bEnable:=FALSE;
		END_FOR
        FOR i:=1 TO ARRAYSIZE_VIRTUAL DO
            astAxes[IDs_VirtualNoCalibrationAxes[i]].stControl.bEnable:=FALSE;
		END_FOR
       astAxes[AXIS_MEASUREMENT_ANGLE].stControl.bEnable := FALSE;
	END_IF

setPos_Drad(Axis:= astAxes[AXIS_DRAD].Axis);
setPos_Dtank_Length(Axis:=astAxes[AXIS_DTANK_LENGTH].Axis);
setPos_Dtank_Pivot_To_Window(Axis:=astAxes[AXIS_DTANK_PIVOT_TO_WINDOW].Axis);
setPos_Drad.Execute:= FALSE;
setPos_Dtank_Length.Execute:= FALSE;
setPos_Dtank_Pivot_To_Window.Execute:= FALSE;



//////

//SPG CALLS
MC_ExtSetPointGenFeed(Axis:= astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis, 
        Position:= GVL_INTER.SETPOS_HORIZONTAL,
        Velocity:=GVL_INTER.SETVELO_HORIZONTAL,
        Direction:= GVL_INTER.SETDIR_HORIZONTAL, Acceleration:= 0);
        
MC_ExtSetPointGenFeed(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis, 
        Position:= GVL_INTER.SETPOS_COMBINED_VERTICAL,
        Velocity:=GVL_INTER.SETVELO_COMBINED_VERTICAL,
        Direction:= GVL_INTER.SETDIR_COMBINED_VERTICAL, Acceleration:= 0);

MC_ExtSetPointGenFeed(Axis:= astAxes[AXIS_ROTATION].Axis, 
        Position:= GVL_INTER.SETPOS_ROTATION,
        Velocity:=GVL_INTER.SETVELO_ROTATION,
        Direction:= GVL_INTER.SETDIR_ROTATION, Acceleration:= 0);

fbSPG_Y_Enable(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis);
fbSPG_Y_Disable(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis);
fbSPG_Z_Enable(Axis:=astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis);
fbSPG_Z_Disable(Axis:=astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis);
fbSPG_Rot_Enable(Axis:=astAxes[AXIS_ROTATION].Axis);
fbSPG_Rot_Disable(Axis:=astAxes[AXIS_ROTATION].Axis);

fbSPG_Y_Enable.Execute:= FALSE;
fbSPG_Y_Disable.Execute:= FALSE;
fbSPG_Z_Enable.Execute:= FALSE;
fbSPG_Z_Disable.Execute:= FALSE;
fbSPG_Rot_Enable.Execute:= FALSE;
fbSPG_Rot_Disable.Execute:= FALSE;

GVL_INTER.LOGIC_STATE:= eStateInter;]]></ST>
    </Implementation>
    <Method Name="AbsoluteMove" Id="{6081ed68-b6ed-437f-92c9-8a8848dd8e14}">
      <Declaration><![CDATA[METHOD AbsoluteMove : BOOL
VAR_INPUT
    axisID : UINT;
    fPosition : LREAL;
    
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[astAxes[axisID].stControl.eCommand:= E_MotionFunctions.eMoveAbsolute;
astAxes[axisID].stControl.fPosition:= fPosition;
astAxes[axisID].stControl.bExecute:= TRUE;]]></ST>
      </Implementation>
    </Method>
    <Action Name="actCheckNotMoving" Id="{d9b664e8-786b-499f-ade6-c6e30fa1a8eb}">
      <Implementation>
        <ST><![CDATA[GVL_INTER.REAL_AXES_NOT_MOVING:= astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis.Status.NotMoving AND astAxes[AXIS_COMBINED_VERTICAL].Axis.Status.NotMoving AND astAxes[AXIS_ROTATION].Axis.Status.NotMoving;

GVL_INTER.VIRTUAL_AXES_NOT_MOVING:= 
    astAxes[AXIS_DOFF_ANGLED].Axis.Status.NotMoving AND
    astAxes[AXIS_DOFF_PARALLEL].Axis.Status.NotMoving AND
    astAxes[AXIS_DTANK_LENGTH].Axis.Status.NotMoving AND
    astAxes[AXIS_DTANK_PIVOT_TO_WINDOW].Axis.Status.NotMoving AND
    astAxes[AXIS_DRAD].Axis.Status.NotMoving AND
    astAxes[AXIS_MEASUREMENT_ANGLE].Axis.Status.NotMoving AND
    astAxes[AXIS_MEASUREMENT_ANGLE_OFFSET].Axis.Status.NotMoving AND
    astAxes[AXIS_ROTATION_CALIBRATION].Axis.Status.NotMoving AND
    astAxes[AXIS_ROTATION_SAMPLE].Axis.Status.NotMoving AND
    astAxes[AXIS_COMBINED_VERTICAL_CALIBRATION].Axis.Status.NotMoving AND
    astAxes[AXIS_COMBINED_VERTICAL_SAMPLE].Axis.Status.NotMoving AND
    astAxes[AXIS_HORIZONTAL_CALIBRATION].Axis.Status.NotMoving AND
    astAxes[AXIS_HORIZONTAL_SAMPLE].Axis.Status.NotMoving;]]></ST>
      </Implementation>
    </Action>
    <Action Name="actCheckPositionDeviation" Id="{48a3beaa-86d1-4929-b3bc-c17d3fe46a74}">
      <Implementation>
        <ST><![CDATA[posDevHorizontal:=    astAxes[AXIS_HORIZONTAL_TRANSLATION].stStatus.fActPosition - GVL_INTER.SETPOS_HORIZONTAL;
posDevVertical:=    astAxes[AXIS_COMBINED_VERTICAL].stStatus.fActPosition - GVL_INTER.SETPOS_COMBINED_VERTICAL;
posDevRot:=    astAxes[AXIS_ROTATION].stStatus.fActPosition - GVL_INTER.SETPOS_ROTATION;

bRealDevValid := ABS(posDevHorizontal)<DEVIATION_THRESHOLD AND ABS(posDevVertical)<DEVIATION_THRESHOLD AND ABS(posDevRot)<DEVIATION_THRESHOLD;

(*
//Check position deviations of "default" axes
bDefaultDevValid:= TRUE; //we will AND it with the deviations in the loop
FOR i := 1 TO ARRAYSIZE_VIRTUALCAL DO
    bDefaultDevValid:= bDefaultDevValid AND (ABS(astAxes[IDs_VirtualWithCalibrationAxes[i]].stStatus.fActPosition - calibrationValuesArray[i])<DEVIATION_THRESHOLD);
END_FOR


//Check position deviations of remaining virtual axes
bRecoveryDevValid:= bDefaultDevValid; //Use default dev as starting point before iterator
FOR i := 1 TO ARRAYSIZE_VIRTUAL DO
    bRecoveryDevValid:= bRecoveryDevValid AND (ABS(astAxes[IDs_VirtualNoCalibrationAxes[i]].stStatus.fActPosition)<DEVIATION_THRESHOLD);
END_FOR
*)

////
////
////
//THIS IS NEW LOGIC THAT OVERRIDES WHAT'S CURRENTLY HAPPENING, BE CAREFUL
bRecoveryDevValid:= TRUE;
FOR i:=1 TO ARRAYSIZE_ALLVIRTUALS DO
    aVirtualAxisDefaults[i].deviation:= ABS(astAxes[aVirtualAxisDefaults[i].axisID].Axis.NcToPlc.ActPos - aVirtualAxisDefaults[i].defaultPosition);
    bRecoveryDevValid:= bRecoveryDevValid AND (aVirtualAxisDefaults[i].deviation<DEVIATION_THRESHOLD);
END_FOR

bVirtualsMoving:= FALSE;
FOR i := 1 TO ARRAYSIZE_ALLVIRTUALS DO
    bVirtualsMoving:= bVirtualsMoving OR astAxes[aVirtualAxisDefaults[i].axisID].Axis.Status.Moving;
END_FOR
/////
/////
/////
    
    
//bVirtualsMoving:= FALSE;
//Looking for any virtual axis moving IDs_VirtualNoCalibrationAxes
//FOR i := 1 TO ARRAYSIZE_VIRTUALCAL DO
//    bVirtualsMoving:= bVirtualsMoving OR astAxes[IDs_VirtualWithCalibrationAxes[i]].Axis.Status.Moving;
//END_FOR
//FOR i := 1 TO ARRAYSIZE_VIRTUAL DO
//    bVirtualsMoving:= bVirtualsMoving OR astAxes[IDs_VirtualNoCalibrationAxes[i]].Axis.Status.Moving;
//END_FOR
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actCheckRealSpgStatus" Id="{aa3cfb1c-6529-4170-bdb7-491608be6428}">
      <Implementation>
        <ST><![CDATA[GVL_INTER.KINEMATIC_SPG_ALL_ENABLED:= astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis.Status.ExtSetPointGenEnabled AND astAxes[AXIS_COMBINED_VERTICAL].Axis.Status.ExtSetPointGenEnabled AND astAxes[AXIS_ROTATION].Axis.Status.ExtSetPointGenEnabled;
GVL_INTER.KINEMATIC_SPG_ALL_DISABLED:= NOT (astAxes[AXIS_HORIZONTAL_TRANSLATION].Axis.Status.ExtSetPointGenEnabled) AND NOT (astAxes[AXIS_COMBINED_VERTICAL].Axis.Status.ExtSetPointGenEnabled) AND NOT (astAxes[AXIS_ROTATION].Axis.Status.ExtSetPointGenEnabled);
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actKinematicSetpoints" Id="{f7732646-7f90-42f9-b38f-67cffb5e750d}">
      <Implementation>
        <ST><![CDATA[GVL_INTER.SETPOS_HORIZONTAL:= astAxes[AXIS_HORIZONTAL_VIRTUAL].Axis.NcToPlc.ActPos + astAxes[AXIS_HORIZONTAL_CALIBRATION].Axis.NcToPlc.ActPos + astAxes[AXIS_HORIZONTAL_SAMPLE].Axis.NcToPlc.ActPos;
GVL_INTER.SETVELO_HORIZONTAL:=astAxes[AXIS_HORIZONTAL_VIRTUAL].Axis.NcToPlc.ActVelo + astAxes[AXIS_HORIZONTAL_CALIBRATION].Axis.NcToPlc.ActVelo + astAxes[AXIS_HORIZONTAL_SAMPLE].Axis.NcToPlc.ActVelo;
GVL_INTER.SETPOS_COMBINED_VERTICAL:= astAxes[AXIS_COMBINED_VERTICAL_VIRTUAL].Axis.NcToPlc.ActPos + astAxes[AXIS_COMBINED_VERTICAL_CALIBRATION].Axis.NcToPlc.ActPos + astAxes[AXIS_COMBINED_VERTICAL_SAMPLE].Axis.NcToPlc.ActPos;
GVL_INTER.SETVELO_COMBINED_VERTICAL:= astAxes[AXIS_COMBINED_VERTICAL_VIRTUAL].Axis.NcToPlc.ActVelo + astAxes[AXIS_COMBINED_VERTICAL_CALIBRATION].Axis.NcToPlc.ActVelo + astAxes[AXIS_COMBINED_VERTICAL_SAMPLE].Axis.NcToPlc.ActVelo;
GVL_INTER.SETPOS_ROTATION:= astAxes[AXIS_ROTATION_VIRTUAL].Axis.NcToPlc.ActPos + astAxes[AXIS_ROTATION_CALIBRATION].Axis.NcToPlc.ActPos + astAxes[AXIS_ROTATION_SAMPLE].Axis.NcToPlc.ActPos;
GVL_INTER.SETVELO_ROTATION:= astAxes[AXIS_ROTATION_VIRTUAL].Axis.NcToPlc.ActVelo + astAxes[AXIS_ROTATION_CALIBRATION].Axis.NcToPlc.ActVelo + astAxes[AXIS_ROTATION_SAMPLE].Axis.NcToPlc.ActVelo;

//Horizontal direction
IF GVL_INTER.SETVELO_HORIZONTAL >0 THEN
    GVL_INTER.SETDIR_HORIZONTAL := 1;
ELSIF GVL_INTER.SETVELO_HORIZONTAL<0 THEN
    GVL_INTER.SETDIR_HORIZONTAL := -1;
ELSE
    GVL_INTER.SETDIR_HORIZONTAL := 0;
END_IF

//Vertical Direction
IF GVL_INTER.SETVELO_COMBINED_VERTICAL>0 THEN
    GVL_INTER.SETDIR_COMBINED_VERTICAL := 1;
ELSIF GVL_INTER.SETVELO_COMBINED_VERTICAL<0 THEN
    GVL_INTER.SETDIR_COMBINED_VERTICAL := -1;
ELSE
    GVL_INTER.SETDIR_COMBINED_VERTICAL := 0;
END_IF

//Rotation direction
IF GVL_INTER.SETVELO_ROTATION>0 THEN
    GVL_INTER.SETDIR_ROTATION := 1;
ELSIF GVL_INTER.SETVELO_ROTATION<0 THEN
    GVL_INTER.SETDIR_ROTATION := -1;
ELSE
    GVL_INTER.SETDIR_ROTATION := 0;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="actSyncVertStateMachine" Id="{86ee614e-4a39-40bc-bbfb-49053b8e3adf}">
      <Implementation>
        <ST><![CDATA[CASE eStateVertical OF
        eState_Vertical.init:
            IF NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bError AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bError THEN
                IF NOT GVL_INTER.DECOUPLE_VERTICAL_AXES THEN
                    eStateVertical := eState_Vertical.checkPosition;
                END_IF
			END_IF
            
        eState_Vertical.checkPosition:
            //Assume Z1 and Z2 calibrated to be at same position
            IF ABS(fVerticalSimulatedDeviation)> fVerticalSimulatedDeviationAllowed THEN
                eStateVertical := eState_Vertical.setPosition; //should be setPosition state
            ELSE
                eStateVertical := eState_Vertical.enableSpg;
			END_IF
            
        eState_Vertical.setPosition:
            combinedVerticalSetPos.Position:= astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.fActPosition;
            combinedVerticalSetPos.Execute:= TRUE;
            eStateVertical := eState_Vertical.checkPosition;
            
        eState_Vertical.enableSpg:
            IF astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitBwd AND astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitFwd THEN
                verticalZ1SpgEnable.Execute := TRUE;
                verticalZ2SpgEnable.Execute := TRUE;
                eStateVertical := eState_Vertical.confirmEnableSpg;
            ELSE
                tempZ1Power(Axis:= astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis, Enable:= TRUE, Enable_Negative:=TRUE, Enable_Positive:=TRUE);
			    tempZ2Power(Axis:= astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis, Enable:= TRUE, Enable_Negative:=TRUE, Enable_Positive:=TRUE);
                verticalZ1SpgEnable.Execute := TRUE;
                verticalZ2SpgEnable.Execute := TRUE;
                eStateVertical := eState_Vertical.confirmEnableSpg;
            END_IF
            
        
        eState_Vertical.confirmEnableSpg:
            confirmSpgTimeout.IN:= TRUE;
            //Timeout check
            IF confirmSpgTimeout.Q THEN
                confirmSpgTimeout.IN:= FALSE;
                eStateVertical := eState_Vertical.init;
			END_IF
            IF VerticalAxesSpgEnabled THEN
                eStateVertical := eState_Vertical.operation;
			END_IF
        
        eState_Vertical.operation:
            //DO NOTHING
            CombinedVerticalSetupComplete := TRUE;
            IF NOT VerticalAxesSpgEnabled THEN
                eStateVertical:= eState_Vertical.init;
			END_IF
            IF GVL_INTER.DECOUPLE_VERTICAL_AXES THEN
                eStateVertical := eState_Vertical.disableSpg;
			END_IF
            
        eState_Vertical.disableSpg:
            verticalZ1SpgDisable.Execute:= TRUE;
            verticalZ2SpgDisable.Execute:= TRUE;
            eStateVertical := eState_Vertical.confirmDisableSpg;
            
        eState_Vertical.confirmDisableSpg:
            IF NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.Status.ExtSetPointGenEnabled AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.Status.ExtSetPointGenEnabled THEN
                eStateVertical := eState_Vertical.init;
            ELSE
                eStateVertical := eState_Vertical.disableSpg;
			END_IF
            
	END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="actZSetpoints" Id="{facf07a9-589c-4d38-a5b7-e5a598ba95ba}">
      <Implementation>
        <ST><![CDATA[astAxes[AXIS_COMBINED_VERTICAL].Axis.ReadStatus();
astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.ReadStatus();
astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.ReadStatus();


//If still getting issues after setting up position and velocity control loops correctly
//expose feedback 1 velocity using PDO assignment at drive and then do comparator against this value
//before sending setpoint generator positions

Y1rTrig(CLK:= astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd);

IF(Y1rTrig.Q) THEN
    scalingActive := TRUE;
END_IF
IF scalingActive THEN
    cycleCounter:= cycleCounter+1;
END_IF
IF cycleCounter>500 THEN
    scalingActive := FALSE;
    cycleCounter:=0;
END_IF
//astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd:= TRUE;

//Z1 position check
IF ((astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos < astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos+0.01)OR (astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo<0)) 
    
    AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd THEN
    //ADSLOGSTR(msgCtrlMask:= ADSLOG_MSGTYPE_HINT,msgFmtStr:='HIT',strArg:='');
    fZ1SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ1SetVelo :=0;
    fZ1SetDir := 0;
ELSIF astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos > astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitFwd THEN
    fZ1SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ1SetVelo :=0;
    fZ1SetDir := 0;
ELSE
    IF scalingActive THEN
        fZ1SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
        fZ1SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo * (0.002*cycleCounter);
        fZ1SetDir := combinedVerticalDirection;
    ELSE
        fZ1SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
        fZ1SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo;
        fZ1SetDir := combinedVerticalDirection;
	END_IF
    //fZ1SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
    //fZ1SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo;
    //fZ1SetDir := combinedVerticalDirection;
END_IF

//Z2 position check
IF astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos < astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitBwd THEN
    fZ2SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ2SetVelo :=0;
    fZ2SetDir := 0;
ELSIF astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos > astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitFwd THEN
    fZ2SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ2SetVelo :=0;
    fZ2SetDir := 0;
ELSE
    fZ2SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
    fZ2SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo;
    fZ2SetDir := combinedVerticalDirection;
END_IF

MC_ExtSetPointGenFeed(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis, Position:= fZ1SetPos, Velocity:= fZ1SetVelo, Acceleration:= 0, Direction:= fZ1SetDir);
MC_ExtSetPointGenFeed(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis, Position:= fZ2SetPos, Velocity:= fZ2SetVelo, Acceleration:= 0, Direction:= fZ2SetDir);
]]></ST>
      </Implementation>
    </Action>
    <Method Name="CheckNcErrors" Id="{7139bf26-abbf-4cba-b321-d9387e4f0885}">
      <Declaration><![CDATA[METHOD CheckNcErrors : BOOL
VAR_INPUT
END_VAR
VAR
    i : UINT := 5;
    Error : BOOL := FALSE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i :=5 TO GVL_APP.nAXIS_NUM DO
    IF astAxes[i].stStatus.bError THEN
        Error := TRUE;
	END_IF
END_FOR
CheckNcErrors := Error;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckRealLimits" Id="{01c59cda-6c3f-45b5-9bb3-083eba480fd4}">
      <Declaration><![CDATA[METHOD CheckRealLimits : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//TRUE ON LIMIT HIT
CheckRealLimits:= NOT(astAxes[AXIS_ROTATION].stInputs.bLimitBwd) OR NOT(astAxes[AXIS_ROTATION].stInputs.bLimitFwd) OR
    NOT(astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitBwd) OR NOT(astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitFwd) OR
    NOT(astAxes[AXIS_HORIZONTAL_TRANSLATION].stInputs.bLimitBwd) OR NOT(astAxes[AXIS_HORIZONTAL_TRANSLATION].stInputs.bLimitFwd);]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckVerticalCalibration" Id="{e1036243-04e4-4263-b466-d17b80a88071}">
      <Declaration><![CDATA[METHOD CheckVerticalCalibration : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CheckVerticalCalibration := astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.Status.Homed AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.Status.Homed;]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckZSpgStatus" Id="{be3f907d-6383-4f00-95cd-2d71447606c2}">
      <Declaration><![CDATA[METHOD CheckZSpgStatus : BOOL
VAR
    SpgSet : BOOL := FALSE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SpgSet := astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.Status.ExtSetPointGenEnabled AND astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.Status.ExtSetPointGenEnabled;
CheckZSpgStatus := SpgSet;]]></ST>
      </Implementation>
    </Method>
    <Method Name="DisableAxes" Id="{445cd5b3-7fd2-4adb-8098-44aeb3439028}">
      <Declaration><![CDATA[METHOD DisableAxes : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[astAxes[AXIS_HORIZONTAL_TRANSLATION].stControl.bEnable :=FALSE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stControl.bEnable :=FALSE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stControl.bEnable :=FALSE;
astAxes[AXIS_ROTATION].stControl.bEnable :=FALSE;
GVL_INTER.DISABLE_ALL_AXES := FALSE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="EnableAxes" Id="{b0c85ed2-0ac0-448f-af10-0513bd266d32}">
      <Declaration><![CDATA[METHOD EnableAxes : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[astAxes[AXIS_HORIZONTAL_TRANSLATION].stControl.bEnable :=TRUE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stControl.bEnable :=TRUE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stControl.bEnable :=TRUE;
astAxes[AXIS_ROTATION].stControl.bEnable :=TRUE;
GVL_INTER.ENABLE_ALL_AXES := FALSE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetAll" Id="{e4647f95-e102-4ec6-b060-9c49e98b19a4}">
      <Declaration><![CDATA[METHOD ResetAll : BOOL
VAR_INPUT
END_VAR

VAR
    i : UINT :=5;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i :=5 TO GVL_APP.nAXIS_NUM DO
        astAxes[i].stControl.bReset:= TRUE;
END_FOR

GVL_INTER.RESET_ALL := FALSE;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>