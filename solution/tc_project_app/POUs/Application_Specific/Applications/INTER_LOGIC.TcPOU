<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="INTER_LOGIC" Id="{da89d596-93f4-468f-9a43-1a72f2055b25}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM INTER_LOGIC
VAR
    NcAxisError : BOOL;
    LogicError : BOOL;
    
    decoupleVerticalMotion : BOOL := FALSE;
    
    safetyFTrig : F_TRIG;
    safetyResetTON : TON;
    safetyResetLatch : BOOL :=FALSE;
    
    
    CombinedVerticalSetupComplete : BOOL := FALSE;
    AllowedVerticalLag : LREAL := 0.2;  //How much offset is allowed between two vertical axes when synced
    VerticalAxesCalibrated : BOOL := FALSE;
    VerticalAxesSpgEnabled : BOOL := FALSE;
    
    verticalZ1SpgEnable : MC_ExtSetPointGenEnable;
    verticalZ1SpgDisable : MC_ExtSetPointGenDisable;
    verticalZ2SpgEnable : MC_ExtSetPointGenEnable;
    verticalZ2SpgDisable : MC_ExtSetPointGenDisable;
    
    
    combinedVerticalSetPos : MC_SetPosition();
    
    eStateVertical : eState_Vertical := eState_Vertical.init;
    fVerticalSimulatedDeviation : LREAL;
    fVerticalSimulatedDeviationAllowed : LREAL := 0.1;
    confirmSpgTimeout : TON;
    
    tempZ1Power : MC_Power;
    tempZ2Power : MC_Power;
    
    fZ1SetPos : LREAL;
    fZ1SetVelo : LREAL;
    fZ2SetPos : LREAL;
    fZ2SetVelo : LREAL;
    fZ1SetDir : DINT;
    fZ2SetDir : DINT;
    combinedVerticalDirection : DINT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF GVL_INTER.ENABLE_ALL_AXES THEN
    EnableAxes();
END_IF

IF GVL_INTER.DISABLE_ALL_AXES THEN
    DisableAxes();
END_IF

//SAFETY RESET LOGIC (RESET AXES ON ESTOP RESET)
safetyFTrig(CLK:= GVL_Safety.SafetyReset);
IF safetyFTrig.Q THEN
    safetyResetLatch := TRUE;
END_IF

safetyResetTON(IN:= safetyResetLatch, PT:=T#1S);

IF safetyResetTON.Q THEN
    safetyResetLatch:= FALSE;
    GVL_INTER.RESET_ALL := TRUE;
END_IF

IF GVL_INTER.RESET_ALL THEN
    ResetAll();
END_IF

//Check for errors at NC level
NcAxisError := CheckNcErrors();
VerticalAxesCalibrated := CheckVerticalCalibration();
VerticalAxesSpgEnabled := CheckZSpgStatus();




(* Current thoughts,
Not sure I like the combined vertical axis, seems to add more hassle than it's worth as I have to set the position and such.
however, would be easier to link in a fail safe such that if mismatch between Z1 and Z2 position, then kill the enable/motion
Probably should progress with this route.
Also having to run the PLC to match NC cycle time otherwise position loop gets LOUD
Priority for next task:
Sort out the position mismatch fail safe AND monitor to ensure both axes are functional before allowing combined Z to move
MULTIPLE LAYERS OF FAILSAFE for synchronisation
Also setup the state logic for the setpoint generator of the Z
needs to handle the axes initially being in error before STO cleared, handle position setting,
Exiting this coupling for maintenance (tweaking of position)
And what happens when something falls over

*)
IF GVL_INTER.RUN_COUPLED_VERTICAL THEN
    ////////////// RUN ALL THE TIME ///////////////////////////////////////        
    //Enable linking
    IF astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bEnabled AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bEnabled THEN
        //Only enable virtual axis if both RAW axes are homed/calibrated
        IF VerticalAxesCalibrated AND  VerticalAxesSpgEnabled THEN
            astAxes[AXIS_COMBINED_VERTICAL].stControl.bEnable := TRUE;
        ELSE 
            astAxes[AXIS_COMBINED_VERTICAL].stControl.bEnable := FALSE;
		END_IF
	END_IF
    
    //Fwd limit linking
    astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitFwd := (astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitFwd AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitFwd);
    //Bwd limit linking
    astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitBwd := (astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitBwd AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd);
    
    fVerticalSimulatedDeviation := astAxes[AXIS_COMBINED_VERTICAL].stStatus.fActPosition - astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.fActPosition;
    
    confirmSpgTimeout(PT:=T#1S);
    /////////////////////////////////////////////////////////////////////
    
    IF astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bError AND astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bError THEN
        eStateVertical:= eState_Vertical.init;
	END_IF
    
    CASE eStateVertical OF
        eState_Vertical.init:
            IF NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.bError AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stStatus.bError THEN
                IF NOT decoupleVerticalMotion THEN
                    eStateVertical := eState_Vertical.checkPosition;
                END_IF
			END_IF
            
        eState_Vertical.checkPosition:
            //Assume Z1 and Z2 calibrated to be at same position
            IF ABS(fVerticalSimulatedDeviation)> fVerticalSimulatedDeviationAllowed THEN
                eStateVertical := eState_Vertical.setPosition; //should be setPosition state
            ELSE
                eStateVertical := eState_Vertical.enableSpg;
			END_IF
            
        eState_Vertical.setPosition:
            combinedVerticalSetPos.Position:= astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stStatus.fActPosition;
            combinedVerticalSetPos.Execute:= TRUE;
            eStateVertical := eState_Vertical.checkPosition;
            
        eState_Vertical.enableSpg:
            IF astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitBwd AND astAxes[AXIS_COMBINED_VERTICAL].stInputs.bLimitFwd THEN
                verticalZ1SpgEnable.Execute := TRUE;
                verticalZ2SpgEnable.Execute := TRUE;
                eStateVertical := eState_Vertical.confirmEnableSpg;
            ELSE
                tempZ1Power(Axis:= astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis, Enable:= TRUE, Enable_Negative:=TRUE, Enable_Positive:=TRUE);
			    tempZ2Power(Axis:= astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis, Enable:= TRUE, Enable_Negative:=TRUE, Enable_Positive:=TRUE);
                verticalZ1SpgEnable.Execute := TRUE;
                verticalZ2SpgEnable.Execute := TRUE;
                eStateVertical := eState_Vertical.confirmEnableSpg;
            END_IF
            
        
        eState_Vertical.confirmEnableSpg:
            confirmSpgTimeout.IN:= TRUE;
            //Timeout check
            IF confirmSpgTimeout.Q THEN
                confirmSpgTimeout.IN:= FALSE;
                eStateVertical := eState_Vertical.init;
			END_IF
            IF VerticalAxesSpgEnabled THEN
                eStateVertical := eState_Vertical.operation;
			END_IF
        
        eState_Vertical.operation:
            //DO NOTHING
            IF NOT VerticalAxesSpgEnabled THEN
                eStateVertical:= eState_Vertical.init;
			END_IF
            IF decoupleVerticalMotion THEN
                eStateVertical := eState_Vertical.disableSpg;
			END_IF
            
        eState_Vertical.disableSpg:
            verticalZ1SpgDisable.Execute:= TRUE;
            verticalZ2SpgDisable.Execute:= TRUE;
            eStateVertical := eState_Vertical.confirmDisableSpg;
            
        eState_Vertical.confirmDisableSpg:
            IF NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.Status.ExtSetPointGenEnabled AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.Status.ExtSetPointGenEnabled THEN
                eStateVertical := eState_Vertical.init;
            ELSE
                eStateVertical := eState_Vertical.disableSpg;
			END_IF
            
	END_CASE
    

    
END_IF



combinedVerticalSetPos(Axis:= astAxes[AXIS_COMBINED_VERTICAL].Axis);
combinedVerticalSetPos.Execute:= FALSE;

IF(astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.ActVelo>0) THEN
    combinedVerticalDirection := 1;
ELSIF (astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.ActVelo<0) THEN
    combinedVerticalDirection := -1;
ELSE 
    combinedVerticalDirection := 0;
END_IF

actZSetpoints();
verticalZ1SpgEnable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis);
verticalZ1SpgEnable.Execute:= FALSE;
verticalZ1SpgDisable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis);
verticalZ1SpgDisable.Execute:= FALSE;
verticalZ2SpgEnable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis);
verticalZ2SpgEnable.Execute:= FALSE;
verticalZ2SpgDisable(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis);
verticalZ2SpgDisable.Execute:= FALSE;

IF CombinedVerticalSetupComplete AND GVL_INTER.RUN_KINEMATICS THEN
    //
END_IF

]]></ST>
    </Implementation>
    <Action Name="actZSetpoints" Id="{facf07a9-589c-4d38-a5b7-e5a598ba95ba}">
      <Implementation>
        <ST><![CDATA[astAxes[AXIS_COMBINED_VERTICAL].Axis.ReadStatus();
astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.ReadStatus();
astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.ReadStatus();

//Z1 position check
IF ((astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos < astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos)OR (astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo<0)) 
    
    AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitBwd THEN
    //ADSLOGSTR(msgCtrlMask:= ADSLOG_MSGTYPE_HINT,msgFmtStr:='HIT',strArg:='');
    fZ1SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ1SetVelo :=0;
    fZ1SetDir := 0;
ELSIF astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos > astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stInputs.bLimitFwd THEN
    fZ1SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ1SetVelo :=0;
    fZ1SetDir := 0;
ELSE
    fZ1SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
    fZ1SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo;
    fZ1SetDir := combinedVerticalDirection;
END_IF

//Z2 position check
IF astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos < astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitBwd THEN
    fZ2SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ2SetVelo :=0;
    fZ2SetDir := 0;
ELSIF astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos > astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos AND NOT astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stInputs.bLimitFwd THEN
    fZ2SetPos := astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.NcToPlc.ActPos; // DON'T MOVE
    fZ2SetVelo :=0;
    fZ2SetDir := 0;
ELSE
    fZ2SetPos := astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetPos; // DON'T MOVE
    fZ2SetVelo :=astAxes[AXIS_COMBINED_VERTICAL].Axis.NcToPlc.SetVelo;
    fZ2SetDir := combinedVerticalDirection;
END_IF

MC_ExtSetPointGenFeed(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis, Position:= fZ1SetPos, Velocity:= fZ1SetVelo, Acceleration:= 0, Direction:= fZ1SetDir);
MC_ExtSetPointGenFeed(Axis:=astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis, Position:= fZ2SetPos, Velocity:= fZ2SetVelo, Acceleration:= 0, Direction:= fZ2SetDir);
]]></ST>
      </Implementation>
    </Action>
    <Method Name="CheckNcErrors" Id="{7139bf26-abbf-4cba-b321-d9387e4f0885}">
      <Declaration><![CDATA[METHOD CheckNcErrors : BOOL
VAR_INPUT
END_VAR
VAR
    i : UINT := 5;
    Error : BOOL := FALSE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i :=5 TO GVL_APP.nAXIS_NUM DO
    IF astAxes[i].stStatus.bError THEN
        Error := TRUE;
	END_IF
END_FOR
CheckNcErrors := Error;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckVerticalCalibration" Id="{e1036243-04e4-4263-b466-d17b80a88071}">
      <Declaration><![CDATA[METHOD CheckVerticalCalibration : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CheckVerticalCalibration := astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.Status.Homed AND astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.Status.Homed;]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckZSpgStatus" Id="{be3f907d-6383-4f00-95cd-2d71447606c2}">
      <Declaration><![CDATA[METHOD CheckZSpgStatus : BOOL
VAR
    SpgSet : BOOL := FALSE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SpgSet := astAxes[AXIS_VERTICAL_TRANSLATION_Y1].Axis.Status.ExtSetPointGenEnabled AND astAxes[AXIS_VERTICAL_TRANSLATION_Y2].Axis.Status.ExtSetPointGenEnabled;
CheckZSpgStatus := SpgSet;]]></ST>
      </Implementation>
    </Method>
    <Method Name="DisableAxes" Id="{445cd5b3-7fd2-4adb-8098-44aeb3439028}">
      <Declaration><![CDATA[METHOD DisableAxes : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[astAxes[AXIS_HORIZONTAL_TRANSLATION].stControl.bEnable :=FALSE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stControl.bEnable :=FALSE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stControl.bEnable :=FALSE;
astAxes[AXIS_ROTATION].stControl.bEnable :=FALSE;
GVL_INTER.DISABLE_ALL_AXES := FALSE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="EnableAxes" Id="{b0c85ed2-0ac0-448f-af10-0513bd266d32}">
      <Declaration><![CDATA[METHOD EnableAxes : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[astAxes[AXIS_HORIZONTAL_TRANSLATION].stControl.bEnable :=TRUE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y2].stControl.bEnable :=TRUE;
astAxes[AXIS_VERTICAL_TRANSLATION_Y1].stControl.bEnable :=TRUE;
astAxes[AXIS_ROTATION].stControl.bEnable :=TRUE;
GVL_INTER.ENABLE_ALL_AXES := FALSE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetAll" Id="{e4647f95-e102-4ec6-b060-9c49e98b19a4}">
      <Declaration><![CDATA[METHOD ResetAll : BOOL
VAR_INPUT
END_VAR

VAR
    i : UINT :=5;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i :=5 TO GVL_APP.nAXIS_NUM DO
        astAxes[i].stControl.bReset:= TRUE;
END_FOR

GVL_INTER.RESET_ALL := FALSE;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>